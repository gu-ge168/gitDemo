export const reactData=[
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:require('./images/slider1.jpg'),
        title:' React 组件间通讯',
        describe:'React 组件间通讯 说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系： 父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1 兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc. 针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。 （在 React 中，React 组件之间的... ',
        author:"古歌",
        time:"2017-01-16",
        flow:141,
        comments:[],
        enjoy:0,
        id:"7111.html",
        content:'<h2 id="React-组件间通讯">React 组件间通讯</h2><p>说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系：</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910.png" class="alignnone size-full wp-image-2827" alt="" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910.png 1280w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910-300x159.png 300w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910-768x408.png 768w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB19qddNVXXXXcbXVXXXXXXXXXX-1712-910-1024x544.png 1024w" sizes="(max-width: 1280px) 100vw, 1280px" height="680" width="1280"></p><p>父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1</p><p>兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc.</p><p>针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。</p><p>（在 React 中，React 组件之间的关系为从属关系，与 DOM 元素之间的父子关系有所不同，下面只是为了说明方便，将 React 组件的关系类比成父子关系进行阐述）</p><h3 id="父组件向子组件通讯">父组件向子组件通讯</h3><p>通讯是单向的，数据必须是由一方传到另一方。在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  state = {</span><span class="line">    msg: <span class="string">"start"</span></span><span class="line">  };</span><span class="line">  componentDidMount() {</span><span class="line">    setTimeout(() =&gt; {</span><span class="line">      <span class="keyword">this</span>.setState({</span><span class="line">        msg: <span class="string">"end"</span></span><span class="line">      });</span><span class="line">    }, <span class="number">1000</span>);</span><span class="line">  }</span><span class="line">  render() {</span><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child_1</span> <span class="attr">msg</span>=<span class="string">{this.state.msg}</span> /&gt;</span>;</span>  }}class Child_1 extends Component{  render() {    return <span class="tag">&lt;<span class="name">p</span>&gt;</span>{this.props.msg}<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  }}</span></pre></td></tr></tbody></table></figure><p>如果父组件与子组件之间不止一个层级，如 Parent 与 Child_1_1 这样的关系，可通过 <code>... 运算符</code>（Object 剩余和展开属性），将父组件的信息，以更简洁的方式传递给更深层级的子组件。通过这种方式，不用考虑性能的问题，通过 babel 转义后的 <code>... 运算符</code> 性能和原生的一致，且上级组件 props 与 state 的改变，会导致组件本身及其子组件的生命周期改变，</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ... 运算符 向 Child_1_1 传递 Parent 组件的信息</span></span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  render() {</span><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span>      <span class="tag">&lt;<span class="name">p</span>&gt;</span>{this.props.msg}<span class="tag">&lt;/<span class="name">p</span>&gt;</span>      <span class="tag">&lt;<span class="name">Child_1_1</span> {<span class="attr">...this.props</span>}/&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  }}class Child_1_1 extends Component{  render() {    return <span class="tag">&lt;<span class="name">p</span>&gt;</span>{this.props.msg}<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  }}</span></pre></td></tr></tbody></table></figure><h3 id="子组件向父组件通讯">子组件向父组件通讯</h3><p>在上一个例子中，父组件可以通过传递 props 的方式，自顶而下向子组件进行通讯。而子组件向父组件通讯，同样也需要父组件向子组件传递 props 进行通讯，只是父组件传递的，是作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  state = {</span><span class="line">    msg: <span class="string">"start"</span></span><span class="line">  };</span>  <span class="line">  transferMsg(msg) {</span><span class="line">    <span class="keyword">this</span>.setState({</span><span class="line">      msg</span><span class="line">    });</span><span class="line">  }</span><span class="line">  render() {</span><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span>        <span class="tag">&lt;<span class="name">p</span>&gt;</span>child msg: {this.state.msg}<span class="tag">&lt;/<span class="name">p</span>&gt;</span>        <span class="tag">&lt;<span class="name">Child_1</span> <span class="attr">transferMsg</span> = <span class="string">{msg</span> =&gt;</span> this.transferMsg(msg)} /&gt;      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;  }}class Child_1 extends Component{  componentDidMount() {    setTimeout(() =&gt; {      this.props.transferMsg("end")    }, 1000);  }  render() {    return <span class="tag">&lt;<span class="name">div</span>&gt;</span>      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_1 component<span class="tag">&lt;/<span class="name">p</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  }}</span></pre></td></tr></tbody></table></figure><p>在上面的例子中，我们使用了 <code>箭头函数</code>，将父组件的 transferMsg 函数通过 props 传递给子组件，得益于箭头函数，保证子组件在调用 transferMsg 函数时，其内部 <code>this</code> 仍指向父组件。</p><p>当然，对于层级比较深的子组件与父组件之间的通讯，仍可使用 <code>... 运算符</code>，将父组件的调用函数传递给子组件，具体方法和上面的例子类似。</p><h3 id="兄弟组件间通讯">兄弟组件间通讯</h3><p>对于没有直接关联关系的两个节点，就如 Child_1 与 Child_2 之间的关系，他们唯一的关联点，就是拥有相同的父组件。参考之前介绍的两种关系的通讯方式，如果我们向由 Child_1 向 Child_2 进行通讯，我们可以先通过 Child_1 向 Parent 组件进行通讯，再由 Parent 向 Child_2 组件进行通讯，所以有以下代码。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  state = {</span><span class="line">    msg: <span class="string">"start"</span></span><span class="line">  };</span><span class="line">  transferMsg(msg) {</span><span class="line">    <span class="keyword">this</span>.setState({</span><span class="line">      msg</span><span class="line">    });</span><span class="line">  }</span><span class="line">  componentDidUpdate() {</span><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Parent update"</span>);</span><span class="line">  }</span><span class="line">  render() {</span><span class="line">    <span class="keyword">return</span> (</span><span class="line">      &lt;div&gt;</span><span class="line">        &lt;Child_1 transferMsg = {msg =&gt; this.transferMsg(msg)} /&gt;</span><span class="line">        &lt;Child_2 msg = {this.state.msg} /&gt;</span><span class="line">      &lt;/div&gt;</span><span class="line">    );</span><span class="line">  }</span><span class="line">}</span><span class="line">class Child_1 extends Component{</span><span class="line">  componentDidMount() {</span><span class="line">    setTimeout(() =&gt; {</span><span class="line">      this.props.transferMsg("end")</span><span class="line">    }, 1000);</span><span class="line">  }</span><span class="line">  componentDidUpdate() {</span><span class="line">    console.log("Child_1 update");</span><span class="line">  }</span><span class="line">  render() {</span><span class="line">    return &lt;div&gt;</span><span class="line">      &lt;p&gt;child_1 component&lt;/p&gt;</span><span class="line">    &lt;/div&gt;</span><span class="line">  }</span><span class="line">}</span><span class="line">class Child_2 extends Component{</span><span class="line">  componentDidUpdate() {</span><span class="line">    console.log("Child_2 update");</span><span class="line">  }</span><span class="line">  render() {</span><span class="line">    return &lt;div&gt;</span><span class="line">      &lt;p&gt;child_2 component: {this.props.msg}&lt;/p&gt;</span><span class="line">      &lt;Child_2_1 /&gt;</span><span class="line">    &lt;/div&gt;</span><span class="line">  }</span><span class="line">}</span><span class="line">class Child_2_1 extends Component{</span><span class="line">  componentDidUpdate() {</span><span class="line">    console.log("Child_2_1 update");</span><span class="line">  }</span><span class="line">  render() {</span><span class="line">    return &lt;div&gt;</span><span class="line">      &lt;p&gt;child_2_1 component&lt;/p&gt;</span><span class="line">    &lt;/div&gt;</span><span class="line">  }</span><span class="line">}</span></pre></td></tr></tbody></table></figure><p>然而，这个方法有一个问题，由于 Parent 的 state 发生变化，会触发 Parent 及从属于 Parent 的子组件的生命周期，所以我们在控制台中可以看到，在各个组件中的 componentDidUpdate 方法均被触发。</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1VjpZNVXXXXcIXXXXXXXXXXXX-268-152.png" class="alignnone size-full wp-image-2828" alt="" height="152" width="268"></p><p>有没有更好的解决方式来进行兄弟组件间的通讯，甚至是父子组件层级较深的通讯的呢？</p><h3 id="观察者模式">观察者模式</h3><p>在传统的前端解耦方面，观察者模式作为比较常见一种设计模式，大量使用在各种框架类库的设计当中。即使我们在写 React，在写 JSX，我们核心的部分还是 JavaScript。</p><p>观察者模式也叫 <code>发布者-订阅者模式</code>，发布者发布事件，订阅者监听事件并做出反应，对于上面的代码，我们引入一个小模块，使用观察者模式进行改造。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventProxy <span class="keyword">from</span> <span class="string">"../eventProxy"</span></span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  render() {</span><span class="line">    <span class="keyword">return</span> (</span><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span>        <span class="tag">&lt;<span class="name">Child_1</span>/&gt;</span>        <span class="tag">&lt;<span class="name">Child_2</span>/&gt;</span>      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="line">    );</span><span class="line">  }</span><span class="line">}</span><span class="line"><span class="comment">// componentDidUpdate 与 render 方法与上例一致</span></span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  componentDidMount() {</span><span class="line">    setTimeout(() =&gt; {</span><span class="line">      <span class="comment">// 发布 msg 事件</span></span><span class="line">      eventProxy.trigger(<span class="string">"msg"</span>, <span class="string">"end"</span>);</span><span class="line">    }, <span class="number">1000</span>);</span><span class="line">  }</span><span class="line">}</span><span class="line"><span class="comment">// componentDidUpdate 方法与上例一致</span></span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  state = {</span><span class="line">    msg: <span class="string">"start"</span></span><span class="line">  };</span><span class="line">  componentDidMount() {</span><span class="line">  	<span class="comment">// 监听 msg 事件</span></span><span class="line">    eventProxy.on(<span class="string">"msg"</span>, (msg) =&gt; {</span><span class="line">      <span class="keyword">this</span>.setState({</span><span class="line">        msg</span><span class="line">      });</span><span class="line">    });</span><span class="line">  }</span><span class="line">  render() {</span><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span>      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_2 component: {this.state.msg}<span class="tag">&lt;/<span class="name">p</span>&gt;</span>      <span class="tag">&lt;<span class="name">Child_2_1</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="line">  }</span><span class="line">}</span></pre></td></tr></tbody></table></figure><p>我们在 child_2 组件的 componentDidMount 中订阅了 <code>msg</code> 事件，并在 child_1 componentDidMount 中，在 1s 后发布了 <code>msg</code> 事件，child_2 组件对 <code>msg</code> 事件做出相应，更新了自身的 state，我们可以看到，由于在整个通讯过程中，只改变了 child_2 的 state，因而只有 child_2 和 child_2_1 出发了一次更新的生命周期。</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1WLJFNVXXXXaeXVXXXXXXXXXX-322-82.png" class="alignnone size-full wp-image-2829" alt="" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1WLJFNVXXXXaeXVXXXXXXXXXX-322-82.png 322w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1WLJFNVXXXXaeXVXXXXXXXXXX-322-82-300x76.png 300w" sizes="(max-width: 322px) 100vw, 322px" height="82" width="322"></p><p>而上面代码中，神奇的 eventProxy.js 究竟是怎样的一回事呢？</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="comment">// eventProxy.js</span></span><span class="line"><span class="meta">"use strict"</span>;</span><span class="line"><span class="keyword">const</span> eventProxy = {</span><span class="line">  onObj: {},</span><span class="line">  oneObj: {},</span><span class="line">  on: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>{</span><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.onObj[key] === <span class="literal">undefined</span>) {</span><span class="line">      <span class="keyword">this</span>.onObj[key] = [];</span><span class="line">    }</span><span class="line">    <span class="keyword">this</span>.onObj[key].push(fn);</span><span class="line">  },</span><span class="line">  one: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>{</span><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.oneObj[key] === <span class="literal">undefined</span>) {</span><span class="line">      <span class="keyword">this</span>.oneObj[key] = [];</span><span class="line">    }</span><span class="line">    <span class="keyword">this</span>.oneObj[key].push(fn);</span><span class="line">  },</span><span class="line">  off: <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>{</span><span class="line">    <span class="keyword">this</span>.onObj[key] = [];</span><span class="line">    <span class="keyword">this</span>.oneObj[key] = [];</span><span class="line">  },</span><span class="line">  trigger: <span class="function"><span class="keyword">function</span>() </span>{</span><span class="line">    <span class="keyword">let</span> key, args;</span><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">0</span>) {</span><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><span class="line">    }</span><span class="line">    key = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><span class="line">    args = [].concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.onObj[key] !== <span class="literal">undefined</span></span><span class="line">      &amp;&amp; <span class="keyword">this</span>.onObj[key].length &gt; <span class="number">0</span>) {</span><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.onObj[key]) {</span><span class="line">        <span class="keyword">this</span>.onObj[key][i].apply(<span class="literal">null</span>, args);</span><span class="line">      }</span><span class="line">    }</span><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.oneObj[key] !== <span class="literal">undefined</span></span><span class="line">      &amp;&amp; <span class="keyword">this</span>.oneObj[key].length &gt; <span class="number">0</span>) {</span><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> <span class="keyword">this</span>.oneObj[key]) {</span><span class="line">        <span class="keyword">this</span>.oneObj[key][i].apply(<span class="literal">null</span>, args);</span><span class="line">        <span class="keyword">this</span>.oneObj[key][i] = <span class="literal">undefined</span>;</span><span class="line">      }</span><span class="line">      <span class="keyword">this</span>.oneObj[key] = [];</span><span class="line">    }</span><span class="line">  }</span><span class="line">};</span><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventProxy;</span></pre></td></tr></tbody></table></figure><p>eventProxy 中，总共有 on、one、off、trigger 这 4 个函数：</p><ul><li><strong>on、one：</strong>on 与 one 函数用于订阅者监听相应的事件，并将事件响应时的函数作为参数，on 与 one 的唯一区别就是，使用 one 进行订阅的函数，只会触发一次，而 使用 on 进行订阅的函数，每次事件发生相应时都会被触发。</li><li><strong>trigger：</strong>trigger 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数。</li><li><strong>off：</strong>用于解除所有订阅了某个事件的所有函数。</li></ul><h3 id="Flux-与-Redux">Flux 与 Redux</h3><p>Flux 作为 Facebook 发布的一种应用架构，他本身是一种模式，而不是一种框架，基于这个应用架构模式，在开源社区上产生了众多框架，其中最受欢迎的就是我们即将要说的 Redux。更多关于 Flux 和 Redux 的介绍这里就不一一展开，有兴趣的同学可以好好看看 <a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux 官方介绍<i class="icon-link"></i></a>、<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html" target="_blank" rel="external">Flux 架构入门教程–阮一峰<i class="icon-link"></i></a>等相关资料。<br>下面将来好好聊聊 Redux 在组件间通讯的方式。</p><p>Flux 需要四大部分组成：Dispatcher、Stores、Views/Controller-Views、Actions，其中的 Views/Controller-Views 可以理解为我们上面所说的 Parent 组件，其作用是从 state 当中获取到相应的数据，并将其传递给他的子组件（descendants）。而另外 3 个部分，则是由 Redux 来提供了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="comment">// 该例子主要对各组件的 componentDidMount 进行改造，其余部分一致</span></span><span class="line"><span class="keyword">import</span> {createStore} <span class="keyword">from</span> <span class="string">"redux"</span></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = {}, action</span>) </span>{</span><span class="line">  <span class="keyword">return</span> action;</span><span class="line">}</span><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  componentDidMount() {</span><span class="line">    setTimeout(() =&gt; {</span><span class="line">      store.dispatch({</span><span class="line">        type: <span class="string">"child_2"</span>,</span><span class="line">        data: <span class="string">"hello"</span></span><span class="line">      })</span><span class="line">    }, <span class="number">1000</span>);</span><span class="line">    setTimeout(() =&gt; {</span><span class="line">      store.dispatch({</span><span class="line">        type: <span class="string">"child_2_1"</span>,</span><span class="line">        data: <span class="string">"bye"</span></span><span class="line">      })</span><span class="line">    }, <span class="number">2000</span>);</span><span class="line">  }</span><span class="line">}</span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  state = {</span><span class="line">    msg: <span class="string">"start"</span></span><span class="line">  };</span>  <span class="line">  componentDidUpdate() {</span><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Child_2 update"</span>, store.getState());</span><span class="line">  }</span><span class="line">  componentDidMount() {</span><span class="line">    store.subscribe(() =&gt; {</span><span class="line">      <span class="keyword">let</span> state = store.getState();</span><span class="line">      <span class="keyword">if</span> (state.type === <span class="string">"child_2"</span>) {</span><span class="line">        <span class="keyword">this</span>.setState({</span><span class="line">          msg: state.data</span><span class="line">        });</span><span class="line">      }</span><span class="line">    });</span><span class="line">  }</span><span class="line">}</span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  state = {</span><span class="line">    msg: <span class="string">"start"</span></span><span class="line">  };</span>	<span class="line">  componentDidUpdate() {</span><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Child_2_1 update"</span>, store.getState());</span><span class="line">  }</span><span class="line">  componentDidMount() {</span><span class="line">    store.subscribe(() =&gt; {</span><span class="line">      <span class="keyword">let</span> state = store.getState();</span><span class="line">      <span class="keyword">if</span> (state.type === <span class="string">"child_2_1"</span>) {</span><span class="line">        <span class="keyword">this</span>.setState({</span><span class="line">          msg: state.data</span><span class="line">        });</span><span class="line">      }</span><span class="line">    });</span><span class="line">  }</span><span class="line">  render() {</span><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span>      <span class="tag">&lt;<span class="name">p</span>&gt;</span>child_2_1 component: {this.state.msg}<span class="tag">&lt;/<span class="name">p</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="line">  }</span><span class="line">}</span></pre></td></tr></tbody></table></figure><p>在上面的例子中，我们将一个名为 <code>reducer</code> 的函数作为参数，生成我们所需要的 store，reducer 接受两个参数，一个是存储在 store 里面的 state，另一个是每一次调用 dispatch 所传进来的 action。reducer 的作用，就是对 dispatch 传进来的 action 进行处理，并将结果返回。而里面的 state 可以通过 store 里面的 getState 方法进行获得，其结果与最后一次通过 reducer 处理后的结果保持一致。</p><p>在 child_1 组件中，我们每隔 1s 通过 store 的 dispatch 方法，向 store 传入包含有 type 字段的 action，reducer 直接将 action 进行返回。</p><p>而在 child_2 与 child_2_1 组件中，通过 store 的 subscribe 方法，监听 store 的变化，触发 dispatch 后，所有通过 subscribe 进行监听的函数都会作出相应，根据当前通过 store.getState() 获取到的结果进行处理，对当前组件的 state 进行设置。所以我们可以在控制台上看到各个组件更新及存储在 store 中 state 的情况：</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1lP8FNVXXXXaEapXXXXXXXXXX-884-122.png" class="alignnone size-full wp-image-2830" alt="" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1lP8FNVXXXXaEapXXXXXXXXXX-884-122.png 884w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1lP8FNVXXXXaEapXXXXXXXXXX-884-122-300x41.png 300w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1lP8FNVXXXXaEapXXXXXXXXXX-884-122-768x106.png 768w" sizes="(max-width: 884px) 100vw, 884px" height="122" width="884"></p><p>在 Redux 中，store 的作用，与 MVC 中的 Model 类似，可以将我们项目中的数据传递给 store，交给 store 进行处理，并可以实时通过 store.getState() 获取到存储在 store 中的数据。我们对上面例子的 reducer 及各个组件的 componentDidMount 做点小修改，看看 store 的这一个特性。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {createStore} <span class="keyword">from</span> <span class="string">"redux"</span></span><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = {}, action</span>) </span>{</span><span class="line">  <span class="keyword">switch</span> (action.type) {</span><span class="line">    <span class="keyword">case</span> <span class="string">"child_2"</span>:</span><span class="line">      state.child_2 = action.data + <span class="string">" child_2"</span>;</span><span class="line">      <span class="keyword">return</span> state;</span><span class="line">    <span class="keyword">case</span> <span class="string">"child_2_1"</span>:</span><span class="line">      state.child_2_1 = action.data + <span class="string">" child_2_1"</span>;</span><span class="line">      <span class="keyword">return</span> state;</span><span class="line">    <span class="keyword">default</span>:</span><span class="line">      <span class="keyword">return</span> state</span><span class="line">  }</span><span class="line">}</span><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  componentDidMount() {</span><span class="line">    setTimeout(() =&gt; {</span><span class="line">      store.dispatch({</span><span class="line">        type: <span class="string">"child_2"</span>,</span><span class="line">        data: <span class="string">"hello"</span></span><span class="line">      })</span><span class="line">    }, <span class="number">1000</span>);</span><span class="line">    setTimeout(() =&gt; {</span><span class="line">      store.dispatch({</span><span class="line">        type: <span class="string">"child_2_1"</span>,</span><span class="line">        data: <span class="string">"bye"</span></span><span class="line">      })</span><span class="line">    }, <span class="number">2000</span>);</span><span class="line">  }</span><span class="line">}</span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  componentDidMount() {</span><span class="line">    store.subscribe(() =&gt; {</span><span class="line">      <span class="keyword">let</span> state = store.getState();</span><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">"child_2"</span>)) {</span><span class="line">        <span class="keyword">this</span>.setState({</span><span class="line">          msg: state.child_2</span><span class="line">        });</span><span class="line">      }</span><span class="line">    });</span><span class="line">  }</span><span class="line">}</span><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>{</span><span class="line">  componentDidMount() {</span><span class="line">    store.subscribe(() =&gt; {</span><span class="line">      <span class="keyword">let</span> state = store.getState();</span><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">"child_2_1"</span>)) {</span><span class="line">        <span class="keyword">this</span>.setState({</span><span class="line">          msg: state.child_2_1</span><span class="line">        });</span><span class="line">      }</span><span class="line">    });</span><span class="line">  }</span><span class="line">}</span></pre></td></tr></tbody></table></figure><p>我们对创建 store 时所传进去的 reducer 进行修改。reducer 中，其参数 state 为当前 store 的值，我们对不同的 action 进行处理，并将处理后的结果存储在 state 中并进行返回。此时，通过 store.getState() 获取到的，就是我们处理完成后的 state。</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216.png" class="alignnone size-full wp-image-2831" alt="" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216.png 1190w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216-300x54.png 300w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216-768x139.png 768w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1tsBQNVXXXXaGaXXXXXXXXXXX-1190-216-1024x186.png 1024w" sizes="(max-width: 1190px) 100vw, 1190px" height="216" width="1190"></p><p>Redux 内部的实现，其实也是基于观察者模式的，reducer 的调用结果，存储在 store 内部的 state 中，并在每一次 reducer 的调用中并作为参数传入。所以在 child_1 组件第 2s 的 dispatch 后，child_2 与 child_2_1 组件通过 subscribe 监听的函数，其通过 getState 获得的值，都包含有 child_2 与 child_2_1 字段的，这就是为什么第 2s 后的响应，child_2 也进行了一次生命周期。所以在对 subscribe 响应后的处理，最好还是先校对通过 getState() 获取到的 state 与当前组件的 state 是否相同。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"></td><td class="code"><pre><span class="line"><span class="comment">// child_2</span></span><span class="line"> componentDidMount() {</span><span class="line">    store.subscribe(() =&gt; {</span><span class="line">      <span class="keyword">let</span> state = store.getState();</span><span class="line">      <span class="keyword">if</span> (state.hasOwnProperty(<span class="string">"child_2"</span>)</span><span class="line">        &amp;&amp; state.child_2 !== <span class="keyword">this</span>.state.msg) {</span><span class="line">        <span class="keyword">this</span>.setState({</span><span class="line">          msg: state.child_2</span><span class="line">        });</span><span class="line">      }</span><span class="line">    });</span><span class="line">  }</span></pre></td></tr></tbody></table></figure><p>加上这样的校验，各个组件的生命周期的触发就符合我们的预期了。</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132.png" class="alignnone size-full wp-image-2832" alt="" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132.png 1254w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132-300x32.png 300w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132-768x81.png 768w, http://www.siyuweb.com/wp-content/uploads/2017/01/TB1vH8PNVXXXXaYaXXXXXXXXXXX-1254-132-1024x108.png 1024w" sizes="(max-width: 1254px) 100vw, 1254px" height="132" width="1254"></p><h2 id="小结">小结</h2><p>Redux 对于组件间的解耦提供了很大的便利，如果你在考虑该不该使用 Redux 的时候，社区里有一句话说，“当你不知道该不该使用 Redux 的时候，那就是不需要的”。Redux 用起来一时爽，重构或者将项目留给后人的时候，就是个大坑，Redux 中的 dispatch 和 subscribe 方法遍布代码的每一个角落。刚刚的例子不是最好的，Flux 设计中的 Controller-Views 概念就是为了解决这个问题出发的，将所有的 subscribe 都置于 Parent 组件（Controller-Views），由最上层组件控制下层组件的表现，然而，这不就是我们所说的 <code>子组件向父组件通讯</code> 这种方式了。</p><p>ps:http://taobaofed.org/blog/2016/11/17/react-components-communication/</p>' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:require('./images/slider2.jpg'),
        title:' react子组件如何向父组件传值',
        describe:'其实很简单，概括起来就是：react中state改变了，组件才会update。父写好state和处理该state的函数，同时将函数名通过props属性值的形式传入子，子调用父的函数，同时引起state变化。子组件要写在父组件之前。具体写法看下面3个例子。 例子1.这里如下图，用户邮箱为父，绿色框为子。 父组件为用户输入的邮箱设好state，即“{email: ""}”，同时写好处理state的函数，即“handleEmail”，这两个名称随意起；再将... ',
        author:"古歌",
        time:"2017-01-08",
        flow: 537,
        comments:[],
        enjoy:0,
        id:"71121.html",
        content:'		<p>其实很简单，概括起来就是：react中state改变了，组件才会update。父写好state和处理该state的函数，同时将函数名通过props属性值的形式传入子，子调用父的函数，同时引起state变化。子组件要写在父组件之前。具体写法看下面3个例子。</p><p>例子1.这里如下图，用户邮箱为父，绿色框为子。 父组件为用户输入的邮箱设好state，即“{email: ""}”，同时写好处理state的函数，即“handleEmail”，这两个名称随意起；再将函数以props的形式传到子组件，子组件只需在事件发生时，调用父组件传过来的函数即可。</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/545055-20160901172841808-1770199726.png" class="alignnone size-full wp-image-2720" alt="" height="69" width="272"></p><div class="cnblogs_code"><pre></pre><pre class="pure-highlightjs"><code class="null hljs xml">//以下所有例子对应的html<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"test"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>&nbsp;</p></div><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="null hljs php"><span class="hljs-comment">//子组件</span><span class="hljs-keyword">var</span> Child = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> (            &lt;div&gt;                请输入邮箱：&lt;input onChange={this.props.handleEmail}/&gt;            &lt;/div&gt;        )    }});<span class="hljs-comment">//父组件，此处通过event.target.value获取子组件的值</span><span class="hljs-keyword">var</span> <span class="hljs-keyword">Parent</span> = React.createClass({    getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> {            email: <span class="hljs-string">""</span>        }    },    handleEmail: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span></span>{        this.setState({email: event.target.value});    },    render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;用户邮箱：{this.state.email}&lt;/div&gt;                &lt;Child name=<span class="hljs-string">"email"</span> handleEmail={this.handleEmail}/&gt;            &lt;/div&gt;        )    }});React.render(  &lt;<span class="hljs-keyword">Parent</span> /&gt;,  document.getElementById(<span class="hljs-string">"test"</span>));</code></pre><p>&nbsp;</p></div><p>例子2.有时候往往需要对数据做处理，再传给父组件，比如过滤或者自动补全等等，下面的例子对用户输入的邮箱做简单验证，自动过滤非数字、字母和"@."以外的字符。</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/545055-20160901184651824-417636944.png" class="alignnone size-full wp-image-2721" alt="" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/545055-20160901184651824-417636944.png 523w, http://www.siyuweb.com/wp-content/uploads/2017/01/545055-20160901184651824-417636944-300x66.png 300w" sizes="(max-width: 523px) 100vw, 523px" height="115" width="523"></p><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">//子组件，handleVal函数处理用户输入的字符，再传给父组件的handelEmail函数</span><span class="hljs-keyword">var</span> Child = React.createClass({    handleVal: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{        <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.refs.emailDom.value;        val = val.replace(<span class="hljs-regexp">/[^0-9|a-z|@|.]/ig</span>,<span class="hljs-string">""</span>);        <span class="hljs-keyword">this</span>.props.handleEmail(val);    },    render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        <span class="hljs-keyword">return</span> (            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                请输入邮箱：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"emailDom"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleVal}</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        )</span>    }});<span class="hljs-comment">//父组件，通过handleEmail接受到的参数，即子组件的值</span><span class="hljs-keyword">var</span> Parent = React.createClass({    getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        <span class="hljs-keyword">return</span> {            email: <span class="hljs-string">""</span>        }    },    handleEmail: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{        <span class="hljs-keyword">this</span>.setState({email: val});    },    render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        <span class="hljs-keyword">return</span> (            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>用户邮箱：{this.state.email}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">handleEmail</span>=<span class="hljs-string">{this.handleEmail}</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        )</span>    }});React.render(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Parent</span> /&gt;</span>,  document.getElementById("test"));</span></code></pre><p>&nbsp;</p></div><p>例子3.如果还存在孙子组件的情况呢？如下图，黑框为父，绿框为子，红框为孙，要求子孙的数据都传给爷爷。原理一样的，只是父要将爷爷对孙子的处理函数直接传下去。</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/545055-20160901185242777-119196007.png" class="alignnone size-full wp-image-2722" alt="" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/545055-20160901185242777-119196007.png 772w, http://www.siyuweb.com/wp-content/uploads/2017/01/545055-20160901185242777-119196007-300x118.png 300w, http://www.siyuweb.com/wp-content/uploads/2017/01/545055-20160901185242777-119196007-768x302.png 768w" sizes="(max-width: 772px) 100vw, 772px" height="304" width="772"></p><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="null hljs php"><span class="hljs-comment">//孙子，将下拉选项的值传给爷爷</span><span class="hljs-keyword">var</span> Grandson = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> (            &lt;div&gt;性别：                &lt;select onChange={this.props.handleSelect}&gt;                    &lt;option value=<span class="hljs-string">"男"</span>&gt;男&lt;/option&gt;                    &lt;option value=<span class="hljs-string">"女"</span>&gt;女&lt;/option&gt;                &lt;/select&gt;            &lt;/div&gt;        )    }});<span class="hljs-comment">//子，将用户输入的姓名传给爹  </span><span class="hljs-comment">//对于孙子的处理函数，父只需用props传下去即可</span><span class="hljs-keyword">var</span> Child = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> (            &lt;div&gt;                姓名：&lt;input onChange={this.props.handleVal}/&gt;                &lt;Grandson handleSelect={this.props.handleSelect}/&gt;            &lt;/div&gt;        )    }});<span class="hljs-comment">//父组件，准备了两个state，username和sex用来接收子孙传过来的值，对应两个函数handleVal和handleSelect</span><span class="hljs-keyword">var</span> <span class="hljs-keyword">Parent</span> = React.createClass({    getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> {            username: <span class="hljs-string">""</span>,            sex: <span class="hljs-string">""</span>        }    },    handleVal: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span></span>{        this.setState({username: event.target.value});    },    handleSelect: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{        this.setState({sex: event.target.value});    },    render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">return</span> (            &lt;div&gt;                &lt;div&gt;用户姓名：{this.state.username}&lt;/div&gt;                &lt;div&gt;用户性别：{this.state.sex}&lt;/div&gt;                &lt;Child handleVal={this.handleVal} handleSelect={this.handleSelect}/&gt;            &lt;/div&gt;        )    }});React.render(  &lt;<span class="hljs-keyword">Parent</span> /&gt;,  document.getElementById(<span class="hljs-string">"test"</span>));</code></pre><p>&nbsp;</p><div class="cnblogs_code_toolbar"></div></div>' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:require('./images/slider3.jpg'),
        title:'使用Redux管理你的React应用 ',
        describe:"因为redux和react的版本更新的比较频繁，博客园这里用的redux版本是1.0.1，如果你关心最新版本的使用技巧，欢迎来我的Github查看(https://github.com/matthew-sun/blog/issues/18) ，我会在这里进行持续的更新和纠错。 React是最好的前端库，因为其发源于世界上最好的后端语言框架。 ---信仰 4.0 will likely be the last major release. Use Redux instead. It's really great. —Flummox框架作者 acdliteA...",
        author:"古歌",
        time:"2017-01-08",
        flow:346,
        comments:[],
        enjoy:2,
        id:"7113.html",
        content:'		<address>因为redux和react的版本更新的比较频繁，博客园这里用的redux版本是1.0.1，如果你关心最新版本的使用技巧，欢迎来我的Github查看(https://github.com/matthew-sun/blog/issues/18) ，我会在这里进行持续的更新和纠错。</address><blockquote><p>React是最好的前端库，因为其发源于世界上最好的后端语言框架。 ---信仰</p><p>4.0 will likely be the last major release. Use Redux instead. It is really great. —Flummox框架作者 acdliteAndrew Clark</p></blockquote><h4>为什么使用React还需要使用别的框架来搭配？</h4><p>React的核心是使用组件定义界面的表现，是一个View层的前端库，那么在使用React的时候我们通常还需要一套机制去管理组件与组件之间，组件与数据模型之间的通信。</p><h4>为什么使用Redux？</h4><p>Facebook官方提出了FLUX思想管理数据流，同时也给出了自己的<a href="https://github.com/facebook/flux">实现<i class="icon-link"></i></a>来管理React应用。可是当我打开<a href="https://github.com/facebook/flux">FLUX<i class="icon-link"></i></a>的文档时候，繁琐的实现，又臭又长的文档，实在难以让我有使用它的欲望。幸好，社区中和我有类似想法的不在少数，github上也涌现了一批关于实现FLUX的框架，比较出名的有<a href="https://github.com/rackt/redux">Redux<i class="icon-link"></i></a>,<a href="https://github.com/reflux/refluxjs">Reflux<i class="icon-link"></i></a>,<a href="https://github.com/acdlite/flummox">Flummox<i class="icon-link"></i></a>。</p><p>其中Redux的简单和有趣的编程体验是最吸引我的地方。</p><ul><li>简单。和其它的FLUX实现不一样，Redux只有唯一的state树，不管项目变的有多复杂，我也仅仅只需要管理一个State树。可能你会有疑问，一个state树就够用了？这个state树该有多大？别着急，Redux中的Reducer机制可以解决这个问题。</li><li>有趣。忙于迭代项目的你，体会编程带来的趣味是有多久没有体会到了？瞧下面这张图，右边那个调试工具是啥？整个应用的action和state都这么被轻松的管理了？行为还能被保存，删除，回滚，重置？修改了代码，页面不刷新也能产生变化？别开玩笑了，不行，世界那么大，让我去试试！</li></ul><p><a href="https://camo.githubusercontent.com/a0d66cf145fe35cbe5fb341494b04f277d5d85dd/687474703a2f2f692e696d6775722e636f6d2f4a34476557304d2e676966" target="_blank"><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/1-300x253.jpg" class="aligncenter size-medium wp-image-2712" alt="1" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/1-300x253.jpg 300w, http://www.siyuweb.com/wp-content/uploads/2017/01/1.jpg 768w" sizes="(max-width: 300px) 100vw, 300px" height="253" width="300"></a></p><p>注：Redux开发调试工具：<a href="https://github.com/gaearon/redux-devtools">redux-devtools<i class="icon-link"></i></a><br>React应用无刷新保存工具：<a href="http://gaearon.github.io/react-hot-loader">hot-loader<i class="icon-link"></i></a></p><h5>不明真相的群众，可能这里需要我来安利一下Flux数据流的思想，看图：</h5><pre><code class="hljs">  ╔═════════╗       ╔════════╗       ╔═════════════════╗  ║ Actions ║──────&gt;║ Stores ║──────&gt;║ View Components ║  ╚═════════╝       ╚════════╝       ╚═════════════════╝       ^                                      │       └──────────────────────────────────────┘  注意：图片仅仅是FLUX思想，而不是Facebook的实现。</code></pre><p>大致的过程是这样的，View层不能直接对state进行操作，而需要依赖Actions派发指令来告知Store修改状态，Store接收Actions指令后发生相应的改变，View层同时跟着Store的变化而变化。</p><p>举个例子：A组件要使B组件发生变化。首先，A组件需要执行一个Action，告知绑定B组件的Store发生变化，Store接收到派发的指令后改变，那相应的B组件的视图也就发生了改变。假如C，D，E，F组件绑定了和B组件相同的Store，那么C，D，E，F也会跟着变化。</p><h3>使用React和Redux开发一个小程序</h3><p>为了更好的描述怎么样使用Redux管理React应用，我做了一个Manage Items的小例子。你可以在这里找到全部的源代码：<a href="https://github.com/matthew-sun/redux-example">https://github.com/matthew-sun/redux-example<i class="icon-link"></i></a></p><p>&nbsp;</p><p><a href="https://camo.githubusercontent.com/ddeda49e8c0799a20e9d80ee5e83939e985e4f1e/687474703a2f2f6d6174746865772d73756e2e6769746875622e696f2f696d616765732f6d616e6167652d6974656d732e676966" target="_blank"><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/2-300x178.jpg" class="aligncenter size-medium wp-image-2713" alt="2" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/2-300x178.jpg 300w, http://www.siyuweb.com/wp-content/uploads/2017/01/2.jpg 752w" sizes="(max-width: 300px) 100vw, 300px" height="178" width="300"></a></p><h5>快速查看</h5><div class="cnblogs_Highlighter"></div><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-number">1.</span>git clone git@github.com:matthew-sun/redux-example.git&nbsp;<span class="hljs-number">2.</span>npm install &amp;&amp; npm start&nbsp;<span class="hljs-number">3.</span>open localhost:<span class="hljs-number">3000</span></code></pre><h4>目录结构</h4><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_921698" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs">.+-- app|&nbsp;&nbsp; +-- actions|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- index.js|&nbsp;&nbsp; +-- components|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- content.js|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- footer.js|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- searchBar.js|&nbsp;&nbsp; +-- constants|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- ActionTypes.js|&nbsp;&nbsp; +-- containers|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- App.js|&nbsp;&nbsp; +-- reducers|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- index.js|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- items.js|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-- filter.js|&nbsp;&nbsp; +-- utils|&nbsp;&nbsp; +-- configureStore.js|&nbsp;&nbsp; +-- index.js+-- css|&nbsp;&nbsp; +-- pure.min.css+-- index.html</code></pre><p>&nbsp;</p></div></div><h4>Index.js</h4><p>在入口文件中，我们需要把App和redux建立起联系。Provider是react-redux提供的组件，它的作用是把store和视图绑定在了一起，这里的Store就是那个唯一的State树。当Store发生改变的时候，整个App就可以作出对应的变化。{() =&gt; }是声明了一个返回的函数传进Provider的props.children里，这个方法将会在React的 0.14版本得到简化。</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_639152" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* app/index.js */</span>&nbsp;<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-redux"</span>;<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./containers/App"</span>;<span class="hljs-keyword">import</span> configureStore <span class="hljs-keyword">from</span> <span class="hljs-string">"./configureStore"</span>;&nbsp;<span class="hljs-keyword">const</span> store = configureStore();&nbsp;React.render(&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{() =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span> }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>,&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById("app"));</span></code></pre><p>&nbsp;</p></div></div></div><h4>Constants</h4><p>keyMirror这个方法非常的有用，它可以帮助我们轻松创建与键值key相等的常量。</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_582288" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* app/constants/actionTypes.js */</span>&nbsp;<span class="hljs-keyword">import</span> keyMirror <span class="hljs-keyword">from</span> <span class="hljs-string">"react/lib/keyMirror"</span>;&nbsp;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> keyMirror({&nbsp;&nbsp;&nbsp;&nbsp;ADD_ITEM: <span class="hljs-literal">null</span>,&nbsp;&nbsp;&nbsp;&nbsp;DELETE_ITEM: <span class="hljs-literal">null</span>,&nbsp;&nbsp;&nbsp;&nbsp;DELETE_ALL: <span class="hljs-literal">null</span>,&nbsp;&nbsp;&nbsp;&nbsp;FILTER_ITEM: <span class="hljs-literal">null</span>});&nbsp;<span class="hljs-comment">// 等于</span><span class="hljs-comment">// export const ADD_ITEM = "ADD_ITEM";</span><span class="hljs-comment">// export const DELETE_ITEM = "DELETE_ITEM";</span><span class="hljs-comment">// export const DELETE_ALL = "DELETE_ALL";</span><span class="hljs-comment">// export const FILTER_ITEM = "FILTER_ITEM";</span></code></pre><p>&nbsp;</p></div></div></div><h4>Actions</h4><p>Action向store派发指令，action 函数会返回一个带有 type 属性的 Javascript Plain Object，store将会根据不同的action.type来执行相应的方法。addItem函数的异步操作我使用了一点小技巧，使用<a href="https://github.com/gaearon/redux-thunk">redux-thunk<i class="icon-link"></i></a>中间件去改变dispatch，dispatch是在View层中用bindActionCreators绑定的。使用这个改变的dispatch我们可以向store发送异步的指令。比如说，可以在action中放入向服务端的请求(ajax)，也强烈推荐这样去做。</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_255161" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* app/actions/index.js */</span>&nbsp;<span class="hljs-keyword">import</span> { ADD_ITEM, DELETE_ITEM, DELETE_ALL, FILTER_ITEM } <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants/actionTypes"</span>;&nbsp;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addItem</span>(<span class="hljs-params">item</span>) </span>{&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> dispatch =&gt; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() =&gt; dispatch({type: ADD_ITEM}), <span class="hljs-number">1000</span>)&nbsp;&nbsp;&nbsp;&nbsp;}}<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteItem</span>(<span class="hljs-params">item, e</span>) </span>{&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: DELETE_ITEM,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item&nbsp;&nbsp;&nbsp;&nbsp;}}<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteAll</span>(<span class="hljs-params"></span>) </span>{&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: DELETE_ALL&nbsp;&nbsp;&nbsp;&nbsp;}}<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterItem</span>(<span class="hljs-params">e</span>) </span>{&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span> filterItem = e.target.value;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: FILTER_ITEM,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filterItem&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>&nbsp;</p></div></div></div><h4>Reducers</h4><p>Redux有且只有一个State状态树，为了避免这个状态树变得越来越复杂，Redux通过 Reducers来负责管理整个应用的State树，而Reducers可以被分成一个个Reducer。</p><p>Reduce在javascript Array的方法中出现过，只是不太常用。简单快速的用代码样例来回顾一下：</p><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* Array.prototype.reduce */</span>&nbsp;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<span class="hljs-keyword">var</span> initialValue = <span class="hljs-number">5</span>;<span class="hljs-keyword">var</span> result = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">previousValue, currentValue</span>) </span>{&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> previousValue + currentValue}, initialValue)<span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">// 15</span><span class="hljs-comment">// 该回调函数的返回值为累积结果，并且此返回值在下一次调用该回调函数时作为参数提供。</span><span class="hljs-comment">// 整个函数执行的过程大致是这样 ((((5+1)+2)+3)+4)</span></code></pre><p>&nbsp;</p><p>回到Redux中来看，整个的状态就相当于从[初始状态]merge一个[action.state]从而得到一个新的状态，随着action的不断传入，不断的得到新的状态的过程。(previousState, action) =&gt; newState，注意：任何情况下都不要改变previousState，因为这样View层在比较State的改变时只需要简单比较即可，而避免了深度循环比较。Reducer的数据结构我们可以用<a href="https://github.com/facebook/immutable-js/">immutable-js<i class="icon-link"></i></a>，这样我们在View层只需要<a href="https://github.com/jurassix/react-immutable-render-mixin">react-immutable-render-mixin<i class="icon-link"></i></a>插件就可以轻松的跳过更新那些state没有发生改变的组件子树。</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_1098" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* app/reducers/items.js */</span>&nbsp;<span class="hljs-keyword">import</span> Immutable <span class="hljs-keyword">from</span> <span class="hljs-string">"immutable"</span>;<span class="hljs-keyword">import</span> { ADD_ITEM, DELETE_ITEM, DELETE_ALL } <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants/actionTypes"</span>;&nbsp;<span class="hljs-keyword">const</span> initialItems = Immutable.List([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);&nbsp;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">items</span>(<span class="hljs-params">state = initialItems, action</span>) </span>{&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">switch</span>(action.type) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span> ADD_ITEM:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> state.push( state.size !=<span class="hljs-number">0</span> ? state.get(<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span> : <span class="hljs-number">1</span> );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span> DELETE_ITEM:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> state.delete( state.indexOf(action.item) );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span> DELETE_ALL:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> state.clear();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">default</span>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> state;&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>&nbsp;</p></div></div></div><h5>连接reducers</h5><p>Redux提供的combineReducers函数可以帮助我们把reducer组合在一起，这样我们就可以把Reducers拆分成一个个小的Reducer来管理Store了。</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_740224" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* app/reducers/index.js */</span>&nbsp;<span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">"redux"</span>;<span class="hljs-keyword">import</span> items <span class="hljs-keyword">from</span> <span class="hljs-string">"./items"</span>;<span class="hljs-keyword">import</span> filter <span class="hljs-keyword">from</span> <span class="hljs-string">"./filter"</span>;&nbsp;<span class="hljs-keyword">const</span> rootReducer = combineReducers({&nbsp;&nbsp;items,&nbsp;&nbsp;filter});&nbsp;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> rootReducer;</code></pre><p>&nbsp;</p></div></div></div><h4>Middleware</h4><p>在Redux中，Middleware 主要是负责改变Store中的dispatch方法，从而能处理不同类型的 action 输入，得到最终的 Javascript Plain Object 形式的 action 对象。</p><p>以<a href="https://github.com/gaearon/redux-thunk">redux-thunk<i class="icon-link"></i></a>为例子：</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_110978" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* redux-thunk */</span>&nbsp;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thunkMiddleware</span>(<span class="hljs-params">{ dispatch, getState }</span>) </span>{&nbsp;&nbsp;<span class="hljs-keyword">return</span> next =&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action =&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">typeof</span> action === ‘<span class="hljs-function"><span class="hljs-keyword">function</span>’ ?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-title">action</span>(<span class="hljs-params">dispatch, getState</span>) :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-title">next</span>(<span class="hljs-params">action</span>);}</span></code></pre><p>&nbsp;</p></div></div></div><p>当ThunkMiddleware 判断action传入的是一个函数，就会为该thunk函数补齐dispatch和getState参数，否则，就调用next(action)，给后续的Middleware（Middleware 插件可以被绑定多个）得到使用dispatch的机会。</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_365814" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* app/configureStore.js */</span>&nbsp;<span class="hljs-keyword">import</span> { compose, createStore, applyMiddleware } <span class="hljs-keyword">from</span> <span class="hljs-string">"redux"</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">"redux-thunk"</span>;<span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">"./reducers"</span>;&nbsp;<span class="hljs-keyword">var</span> buildStore = compose(applyMiddleware(thunk), createStore)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">configureStore</span>(<span class="hljs-params">initialState</span>) </span>{&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> buildStore(rootReducer, initialState);}</code></pre><p>&nbsp;</p></div></div></div><h4>UI</h4><p>智能组件和木偶组件，因为本文主要是介绍Redux，对这个感兴趣的同学可以看一下这篇文章<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Smart and Dumb Components<i class="icon-link"></i></a>。本项目中在结构上会把智能组件放在containers中，木偶组件放于components中。</p><h5>containers</h5><p>智能组件，会通过react-redux函数提供的connect函数把state和actions转换为旗下木偶组件所需要的props。</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_787925" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* app/containers/App.js */</span>&nbsp;<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<span class="hljs-keyword">import</span> SearchBar <span class="hljs-keyword">from</span> <span class="hljs-string">"../components/searchBar"</span>;<span class="hljs-keyword">import</span> Content <span class="hljs-keyword">from</span> <span class="hljs-string">"../components/content"</span>;<span class="hljs-keyword">import</span> Footer <span class="hljs-keyword">from</span> <span class="hljs-string">"../components/footer"</span>;<span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-redux"</span>;<span class="hljs-keyword">import</span> ImmutableRenderMixin <span class="hljs-keyword">from</span> <span class="hljs-string">"react-immutable-render-mixin"</span>;<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ItemsActions <span class="hljs-keyword">from</span> <span class="hljs-string">"../actions"</span>;<span class="hljs-keyword">import</span> { bindActionCreators } <span class="hljs-keyword">from</span> <span class="hljs-string">"redux"</span>;&nbsp;<span class="hljs-keyword">let</span> App = React.createClass({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mixins: [ImmutableRenderMixin],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;propTypes: {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items: React.PropTypes.object,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter: React.PropTypes.string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;render() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span> styles = {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;width: <span class="hljs-string">"200px"</span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;margin: <span class="hljs-string">"30px auto 0"</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> actions = <span class="hljs-keyword">this</span>.props.actions;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles}</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Manage Items<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">SearchBar</span> <span class="hljs-attr">filterItem</span>=<span class="hljs-string">{actions.filterItem}</span>/&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Content</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{this.props.items}</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">{this.props.filter}</span> <span class="hljs-attr">deleteItem</span>=<span class="hljs-string">{actions.deleteItem}</span>/&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> <span class="hljs-attr">addItem</span>=<span class="hljs-string">{actions.addItem}</span> <span class="hljs-attr">deleteAll</span>=<span class="hljs-string">{actions.deleteAll}</span>/&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;})&nbsp;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(state =&gt; ({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items: state.items,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter: state.filter}), dispatch =&gt; ({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actions: bindActionCreators(ItemsActions, dispatch)}))(App);</code></pre><p>&nbsp;</p></div></div></div><h5>components</h5><p>木偶组件，各司其职，没有什么关于actions和stores的依赖，拿出项目中也可独立使用，甚至可以和别的actions，stores进行绑定。</p><ul><li>SearchBar：查找Item。</li><li>Content：控制Items的显示，删除一个Item。</li><li>Footer：新增Item，删除全部Item。</li></ul><h4>调试工具</h4><p>使用<a href="https://github.com/gaearon/redux-devtools">redux-devtools<i class="icon-link"></i></a>调试，为你在开发过程中带来乐趣。</p><div class="highlight highlight-javascript"><div class="cnblogs_Highlighter sh-gutter"><div id="highlighter_51625" class="syntaxhighlighter javascript"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">/* app/index.js */</span>&nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderDevTools</span>(<span class="hljs-params">store</span>) </span>{&nbsp;&nbsp;<span class="hljs-keyword">if</span> (__DEBUG__) {&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">let</span> {DevTools, DebugPanel, LogMonitor} = <span class="hljs-built_in">require</span>(<span class="hljs-string">"redux-devtools/lib/react"</span>);&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DebugPanel</span> <span class="hljs-attr">top</span> <span class="hljs-attr">right</span> <span class="hljs-attr">bottom</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">DevTools</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span> <span class="hljs-attr">monitor</span>=<span class="hljs-string">{LogMonitor}</span> /&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">DebugPanel</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;)</span>;&nbsp;&nbsp;}<span class="hljs-keyword">else</span> {&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&nbsp;&nbsp;}}&nbsp;React.render(&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{() =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span> }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{renderDevTools(store)}&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>,&nbsp;&nbsp;document.getElementById("app"));/* app/configureStore.js */&nbsp;var buildStore;if(__DEBUG__) {&nbsp;&nbsp;buildStore = compose(&nbsp;&nbsp;&nbsp;&nbsp;applyMiddleware(thunk),&nbsp;&nbsp;&nbsp;&nbsp;require("redux-devtools").devTools(),&nbsp;&nbsp;&nbsp;&nbsp;require("redux-devtools").persistState(window.location.href.match(/[?&amp;]debug_session=([^&amp;]+)b/)),&nbsp;&nbsp;&nbsp;&nbsp;createStore&nbsp;&nbsp;)}else {&nbsp;&nbsp;buildStore = compose(applyMiddleware(thunk), createStore)}&nbsp;export default function configureStore(initialState) {&nbsp;&nbsp;return buildStore(rootReducer, initialState);}</span></code></pre><p>&nbsp;</p></div></div></div><p>在你的代码中加上上面的两段代码，运行npm run debug命令，就可以用调试工具来管理你的项目了。</p><h4>延伸阅读</h4><ul><li><a href="http://rackt.github.io/redux/index.html">Redux Document<i class="icon-link"></i></a></li><li><a href="https://github.com/xgrommx/awesome-redux">Awesome-redux<i class="icon-link"></i></a></li></ul><h4>写在最后</h4><p>刚接触到Redux和React技术的时候，我几乎是夜夜难以入眠的，技术革新带来的新的思想总是不断的刺激着我的大脑。非常建议你也能来试试Redux，体会我在开发中得到的这种幸福感。</p><p>如果有任何想要了解的，欢迎来我的<a href="https://github.com/matthew-sun">github<i class="icon-link"></i></a>和我一起互动交流。</p>' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:require('./images/slider4.jpg'),
        title:'Redux状态管理方法与实例',
        describe:'状态管理是目前构建单页应用中不可或缺的一环，也是值得花时间学习的知识点。React官方推荐我们使用Redux来管理我们的React应用，同时也提供了Redux的文档来供我们学习，中文版地址为http://cn.redux.js.org/index.html   前言 虽然官方文档上说只需几分钟就能上手 Redux，但是我个人认为即便你看个两三天也可能上手不了，因为文档里面的知识点不仅数量较多，而且还艰涩难懂，不结合一些实例来看很难... ',
        author:"古歌",
        time:"2017-01-08",
        flow:98,
        comments:[],
        enjoy:8,
        id:"7114.html",
        content:'<p>状态管理是目前构建单页应用中不可或缺的一环，也是值得花时间学习的知识点。React官方推荐我们使用Redux来管理我们的React应用，同时也提供了Redux的文档来供我们学习，中文版地址为<a href="http://cn.redux.js.org/index.html">http://cn.redux.js.org/index.html<i class="icon-link"></i></a></p><p>&nbsp;</p><h2>前言</h2><p>虽然官方文档上说只需几分钟就能上手 Redux，但是我个人认为即便你看个两三天也可能上手不了，因为文档里面的知识点不仅数量较多，而且还艰涩难懂，不结合一些实例来看很难用于实际项目中去。</p><p>但是不要担心自己学不会，这不我就给大家带来了这篇干货，也是我学习Redux的心得体验。</p><p>如果你对如何构建React单页应用还不了解的可以先移步我的上一篇文章<a href="https://segmentfault.com/a/1190000005703694">《React 构建单页应用方法与实例》<i class="icon-link"></i></a>。</p><p>那么下面我就将介绍如何利用Redux来管理你的React项目了，而这里我主要教你构建的是基于React + Redux + React-Router的方法，这也是官方文档里介绍的比较少但是项目中却必备的知识点。</p><p>&nbsp;</p><h2>项目目录</h2><p>首先，一个基于React + Redux + React-Router的项目目录可以按照我下方的图片来构建：</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/3148259074-57830c8d6ab09_articlex-186x300.png" class="aligncenter size-medium wp-image-2703" alt="3148259074-57830c8d6ab09_articlex" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/3148259074-57830c8d6ab09_articlex-186x300.png 186w, http://www.siyuweb.com/wp-content/uploads/2017/01/3148259074-57830c8d6ab09_articlex.png 275w" sizes="(max-width: 186px) 100vw, 186px" height="300" width="186"></p><p>其中assets目录用于存放项目的静态资源，如css/图片等，src目录则用于存放React的组件资源。</p><p>&nbsp;</p><h2>入口文件配置</h2><p>在webpack的配置项中，我们需要一个或多个入口文件，这里我就不展示关于package.json及webpack.config.js的文件配置，最后我会提供整个项目的下载链接供大家参考。这里我主要介绍下入口文件index.js的配置说明。</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"></div><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>  <span class="hljs-comment">// 引入React</span><span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span> <span class="hljs-comment">// 引入render方法</span><span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-redux"</span> <span class="hljs-comment">// 利用Provider可以使我们的 store 能为下面的组件所用</span><span class="hljs-keyword">import</span> { Router, browserHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router"</span> <span class="hljs-comment">// Browser history 是由 React Router 创建浏览器应用推荐的 history</span><span class="hljs-keyword">import</span> { syncHistoryWithStore } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-redux"</span> <span class="hljs-comment">// 利用react-router-redux提供的syncHistoryWithStore我们可以结合store同步导航事件</span><span class="hljs-keyword">import</span> finalCreateStore <span class="hljs-keyword">from</span> <span class="hljs-string">"./src/store/configureStore"</span>  <span class="hljs-comment">//引入增强后的store</span><span class="hljs-keyword">import</span> DevTools <span class="hljs-keyword">from</span> <span class="hljs-string">"./src/containers/DevTools"</span>  <span class="hljs-comment">// 引入Redux调试工具DevTools</span><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">"./src/reducers"</span>  <span class="hljs-comment">// 引入reducers集合</span><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">"./src/routes"</span>   <span class="hljs-comment">// 引入路由配置</span><span class="hljs-keyword">import</span> <span class="hljs-string">"./assets/css/bootstrap.min.css"</span>  <span class="hljs-comment">// 引入样式文件</span><span class="hljs-comment">// 给增强后的store传入reducer</span><span class="hljs-keyword">const</span> store = finalCreateStore(reducer)<span class="hljs-comment">// 创建一个增强版的history来结合store同步导航事件</span><span class="hljs-keyword">const</span> history = syncHistoryWithStore(browserHistory, store)render(    {<span class="hljs-comment">/* 利用Provider包裹页面 */</span>}    &lt;Provider store={store}&gt;        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>            {/* 渲染根路由 */}            <span class="hljs-tag">&lt;<span class="hljs-name">Router</span> <span class="hljs-attr">history</span>=<span class="hljs-string">{history}</span> <span class="hljs-attr">routes</span>=<span class="hljs-string">{routes}</span> /&gt;</span>            {/* 渲染调试组件 */}            <span class="hljs-tag">&lt;<span class="hljs-name">DevTools</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>,    document.getElementById("mount"))</span></code></pre><p>&nbsp;</p></div><p>在入口文件中我们尽量只需要保留基本的东西，其余的配置代码我们可以放到相应的配置文件中去，比如路由、reducers及store的配置等。这里我都把它们放置到了独立的js中，只在入口文件中通过import引入，这样管理和维护起来会非常方便，但也会相应增加理解的难度，然而一旦上手就会很容易。那么接下来我们再来看下store配置吧。</p><p>&nbsp;</p><h2>store配置</h2><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">"redux-thunk"</span> <span class="hljs-comment">// redux-thunk 支持 dispatch function，并且可以异步调用它</span><span class="hljs-keyword">import</span> createLogger <span class="hljs-keyword">from</span> <span class="hljs-string">"redux-logger"</span> <span class="hljs-comment">// 利用redux-logger打印日志</span><span class="hljs-keyword">import</span> { createStore, applyMiddleware, compose } <span class="hljs-keyword">from</span> <span class="hljs-string">"redux"</span> <span class="hljs-comment">// 引入redux createStore、中间件及compose </span><span class="hljs-keyword">import</span> DevTools <span class="hljs-keyword">from</span> <span class="hljs-string">"../containers/DevTools"</span> <span class="hljs-comment">// 引入DevTools调试组件</span><span class="hljs-comment">// 调用日志打印方法</span><span class="hljs-keyword">const</span> loggerMiddleware = createLogger()<span class="hljs-comment">// 创建一个中间件集合</span><span class="hljs-keyword">const</span> middleware = [thunk, loggerMiddleware]<span class="hljs-comment">// 利用compose增强store，这个 store 与 applyMiddleware 和 redux-devtools 一起使用</span><span class="hljs-keyword">const</span> finalCreateStore = compose(    applyMiddleware(...middleware),    DevTools.instrument(),)(createStore)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> finalCreateStore</code></pre><p>&nbsp;</p></div><p>这里我们需要了解中间件（Middleware）的概念。middleware 是指可以被嵌入在框架接收请求到产生响应过程之中的代码，你可以在一个项目中使用多个独立的第三方 middleware，如上面的redux-thunk和redux-logger。详细资料请参考官方文档：<br><a href="http://cn.redux.js.org/docs/advanced/Middleware.html">http://cn.redux.js.org/docs/advanced/Mid...<i class="icon-link"></i></a></p><p>&nbsp;</p><h2>路由配置</h2><p>上面的入口文件配置中我们把路由配置部分单独放到了routes.js的文件中，这里我们就来看下其配置：</p><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span> <span class="hljs-comment">// 引入react</span><span class="hljs-keyword">import</span> { Route, IndexRoute } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router"</span> <span class="hljs-comment">// 引入react路由</span><span class="hljs-keyword">import</span> { App, Home, Foo, Bar, Antd } <span class="hljs-keyword">from</span> <span class="hljs-string">"./containers"</span> <span class="hljs-comment">// 引入各容器组件</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{App}</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">IndexRoute</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Home}</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Home}</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"foo"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Foo}</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"bar"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Bar}</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"antd"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Antd}</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span>)</span></code></pre><p>&nbsp;</p></div><p>这里的路由配置和不使用redux时候是一样的，唯一需要了解的是容器组件和展示组件的概念。上面配置文件中的路由加载的组件都可以认为是容器组件。<br>（1）顾名思义，展示组件包含在容器组件中，只用作页面展示，不会定义数据如何读取如何改变，只通过this.props接受数据和回调函数；<br>（2）而容器组件中包含各展示组件的数据，即Props，它们为展示组件或其他组件提供数据和方法。<br>我们应该把它们放在不同的文件夹中，以示区别，如上面“项目目录”中的containers和components文件夹分别存放容器组件和展示组件。具体说明可以参考文章：<a href="http://www.jianshu.com/p/6fa2b21f5df3">http://www.jianshu.com/p/6fa2b21f5df3<i class="icon-link"></i></a></p><p>&nbsp;</p><h2>根组件配置</h2><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span> <span class="hljs-comment">// 引入React</span><span class="hljs-keyword">import</span> { Link } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router"</span> <span class="hljs-comment">// 引入Link处理导航跳转</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{    render() {        <span class="hljs-keyword">return</span>(            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"navbar navbar-default"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container-fluid"</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"navbar-header"</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"navbar-brand"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>Redux<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"nav navbar-nav"</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/index"</span> <span class="hljs-attr">activeStyle</span>=<span class="hljs-string">{{color:</span> "#<span class="hljs-attr">555</span>", <span class="hljs-attr">backgroundColor:</span> "#<span class="hljs-attr">e7e7e7</span>"}}&gt;</span>计数器<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/foo"</span> <span class="hljs-attr">activeStyle</span>=<span class="hljs-string">{{color:</span> "#<span class="hljs-attr">555</span>", <span class="hljs-attr">backgroundColor:</span> "#<span class="hljs-attr">e7e7e7</span>"}}&gt;</span>静态数据<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/bar"</span> <span class="hljs-attr">activeStyle</span>=<span class="hljs-string">{{color:</span> "#<span class="hljs-attr">555</span>", <span class="hljs-attr">backgroundColor:</span> "#<span class="hljs-attr">e7e7e7</span>"}}&gt;</span>动态数据<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/antd"</span> <span class="hljs-attr">activeStyle</span>=<span class="hljs-string">{{color:</span> "#<span class="hljs-attr">555</span>", <span class="hljs-attr">backgroundColor:</span> "#<span class="hljs-attr">e7e7e7</span>"}}&gt;</span>结合antd<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"panel panel-default"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"panel-body"</span>&gt;</span>                        { this.props.children }                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        )</span>    }}</code></pre><p>&nbsp;</p></div><p>整个根组件App.js主要渲染了整个应用的导航和可变区域，这其实和Redux没有关系。需要注意的是to中的URL地址需要和routes.js中的path地址名称一致。</p><p>写到这里还没有介绍Redux中的Action及Reducer的配置，那么接下来就来介绍下。</p><p>&nbsp;</p><h2>Action配置</h2><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-keyword">import</span> { INCREASE, DECREASE, GETSUCCESS, REFRESHDATA } <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants"</span>  <span class="hljs-comment">// 引入action类型名常量</span><span class="hljs-keyword">import</span> <span class="hljs-string">"whatwg-fetch"</span>  <span class="hljs-comment">// 可以引入fetch来进行Ajax</span><span class="hljs-comment">// 这里的方法返回一个action对象</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> increase = n =&gt; {    <span class="hljs-keyword">return</span> {        type: INCREASE,        amount: n    }}<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> decrease = n =&gt; {    <span class="hljs-keyword">return</span> {        type: DECREASE,        amount: n    }}<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> refreshData = () =&gt; {    <span class="hljs-keyword">return</span> {        type: REFRESHDATA    }}<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getSuccess = (json) =&gt; {    <span class="hljs-keyword">return</span> {        type: GETSUCCESS,        json    }}<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchPosts</span>(<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">return</span> dispatch =&gt; {        <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">"data.json"</span>)            .then((res) =&gt; { <span class="hljs-built_in">console</span>.log(res.status); <span class="hljs-keyword">return</span> res.json() })            .then((data) =&gt; {                dispatch(getSuccess(data))            })            .catch((e) =&gt; { <span class="hljs-built_in">console</span>.log(e.message) })        }}<span class="hljs-comment">// 这里的方法返回一个函数进行异步操作</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchPostsIfNeeded</span>(<span class="hljs-params"></span>) </span>{    <span class="hljs-comment">// 注意这个函数也接收了 getState() 方法</span>    <span class="hljs-comment">// 它让你选择接下来 dispatch 什么</span>    <span class="hljs-keyword">return</span> (dispatch, getState) =&gt; {        <span class="hljs-keyword">return</span> dispatch(fetchPosts())    }}</code></pre><p>&nbsp;</p></div><p>上面返回一个action对象的方法叫做“action 创建函数”，它就是生成action的方法，也是store数据的唯一来源。<br>上面返回一个函数的方法叫做“异步action”，这里使用的是Redux Thunk middleware，要引入redux-thunk这个专门的库才能使用，这样我们就可以实现异步Ajax请求改变状态等功能了。</p><p>&nbsp;</p><h2>Reducer配置</h2><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">// reducers/count.js</span><span class="hljs-keyword">import</span> { INCREASE, DECREASE, GETSUCCESS, REFRESHDATA } <span class="hljs-keyword">from</span> <span class="hljs-string">"../constants"</span> <span class="hljs-comment">// 引入action类型常量名</span><span class="hljs-comment">// 初始化state数据</span><span class="hljs-keyword">const</span> initialState = {    number: <span class="hljs-number">1</span>,    lists: [        {text: <span class="hljs-string">"整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。"</span>},         {text: <span class="hljs-string">"惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。"</span>},        {text: <span class="hljs-string">"为了描述 action 如何改变 state tree ，你需要编写 reducers。"</span>},        {text: <span class="hljs-string">"就是这样，现在你应该明白 Redux 是怎么回事了。"</span>}    ],    data: []}<span class="hljs-comment">// 通过dispatch action进入</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">state = initialState, action</span>) </span>{    <span class="hljs-comment">// 根据不同的action type进行state的更新</span>    <span class="hljs-keyword">switch</span>(action.type) {        <span class="hljs-keyword">case</span> INCREASE:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, { number: state.number + action.amount })            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> DECREASE:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, { number: state.number - action.amount })            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> GETSUCCESS:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, { data: action.json })        <span class="hljs-keyword">case</span> REFRESHDATA:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, { data: [] })        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">return</span> state    }}</code></pre><p>&nbsp;</p></div><div class="cnblogs_code_toolbar"></div></div><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-comment">// reducers/index.js</span><span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">"redux"</span> <span class="hljs-comment">// 利用combineReducers 合并reducers</span><span class="hljs-keyword">import</span> { routerReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-redux"</span> <span class="hljs-comment">// 将routerReducer一起合并管理</span><span class="hljs-keyword">import</span> update <span class="hljs-keyword">from</span> <span class="hljs-string">"./count"</span> <span class="hljs-comment">// 引入update这个reducer</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> combineReducers({    update,    routing: routerReducer})</code></pre><p>&nbsp;</p></div><p>这里我们主要需要了解如何通过combineReducers来合并reducers，同时在进入reducer方法后我们必须返回一个state的处理结果来更新state状态，否则会报错。还需注意的是在合并reducers的时候，需要加上routerReducer这个由“react-router-redux”提供的reducer来管理路由的状态更新。</p><p>&nbsp;</p><h2>容器组件</h2><p>上文提到了容器组件和展示组件的区别和含义，这里我们需要在容器组件使用connect来搭配Redux来进行状态管理，这是很关键的一步。</p><div class="cnblogs_code"><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-keyword">import</span> React, { Component, PropTypes } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span> <span class="hljs-comment">// 引入React</span><span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-redux"</span> <span class="hljs-comment">// 引入connect </span><span class="hljs-keyword">import</span> List <span class="hljs-keyword">from</span> <span class="hljs-string">"../components/List"</span>  <span class="hljs-comment">// 引入展示组件List</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{    render() {            <span class="hljs-comment">// 通过this.props获取到lists的值</span>        <span class="hljs-keyword">const</span> { lists } = <span class="hljs-keyword">this</span>.props        <span class="hljs-keyword">return</span>(            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"list-group"</span>&gt;</span>                    {将值传入展示组件}                    { lists.map((e, index) =&gt;                         <span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{e.text}</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span>                    )</span>}                &lt;<span class="hljs-regexp">/ul&gt;            &lt;/</span>div&gt;        )    }}<span class="hljs-comment">// 验证组件中的参数类型</span>Foo.propTypes = {    lists: PropTypes.arrayOf(PropTypes.shape({        text: PropTypes.string.isRequired    }).isRequired).isRequired}<span class="hljs-comment">// 获取state中的lists值</span><span class="hljs-keyword">const</span> getList = state =&gt; {    <span class="hljs-keyword">return</span> {        lists: state.update.lists    }}<span class="hljs-comment">// 利用connect将组件与Redux绑定起来</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(getList)(Foo)</code></pre><p>&nbsp;</p></div><p>在容器组件中我们需要获取state中的初始状态的时候，我们需要使用connect。任何一个从 connect() 包装好的组件都可以得到一个 dispatch 方法作为组件的 props，以及得到全局 state 中所需的任何内容。connect() 的唯一参数是 selector。此方法可以从 Redux store 接收到全局的 state，然后返回组件中需要的 props。详资料请参考文档：<a href="http://cn.redux.js.org/docs/basics/UsageWithReact.html">http://cn.redux.js.org/docs/basics/Usage...<i class="icon-link"></i></a></p><p>&nbsp;</p><h2>展示组件</h2><p>上面的容器组件中引入了一个展示组件List，我们来看下它的代码：</p><pre class="pure-highlightjs"><code class="javascript hljs"><span class="hljs-keyword">import</span> React, { Component, PropTypes } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{    render() {        <span class="hljs-keyword">return</span>(            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span>{this.props.text}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        )</span>    }}List.propTypes = {    text: PropTypes.string.isRequired}</code></pre><p>&nbsp;</p><p>从中我们可以发现，展示组件没有connect的方法，数据是通过this.props来获取的，这样的方式能够是数据的变化清晰可查，便于管理和维护。</p><p>&nbsp;</p><h2>demo演示</h2><p>最后我们来看下这个demo：</p><p><img original="http://www.siyuweb.com/wp-content/uploads/2017/01/170108112328-300x161.png" class="aligncenter size-medium wp-image-2707" alt="170108112328" srcset="http://www.siyuweb.com/wp-content/uploads/2017/01/170108112328-300x161.png 300w, http://www.siyuweb.com/wp-content/uploads/2017/01/170108112328-768x412.png 768w, http://www.siyuweb.com/wp-content/uploads/2017/01/170108112328.png 808w" sizes="(max-width: 300px) 100vw, 300px" height="161" width="300"></p><p>&nbsp;</p><p>整个demo的代码我都上传到了我的github，需要的童鞋可以访问：<a href="https://github.com/luozhihao/redux-basic-example">https://github.com/luozhihao/redux-basic...<i class="icon-link"></i></a>下载</p><p>https://segmentfault.com/a/1190000005933397</p>		' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React",  
        tag:"前端开发",
        images:require('./images/slider5.jpg'),
        title:'React在ES6中的用法 ',
        describe:'入门级Demos 先来几个简单的demo体验一把。注意，例子里ES5的require请通过browserfiy或webpack来实现，如果你还不会用这两样东西，请出门后往前看。 “Hello,XXX”输出 ES5写法： var React = require("react"); var HelloMessage = React.createClass({ render: function() { return (<h1>Hello,{this.props.name}!</h1>); } }); module.exports = React.crea... ',
        author:"古歌",
        time:"2017-01-07",
        flow:1754,
        comments:[],
        enjoy:16,
        id:"7115.html",
        content:'<div class="skin_center_t"><div class="skin_list"><dl class="list_c clearfix detail_list"><dd><div id="article_content" class="skin_detail"><div class="markdown_views"><h1 id="入门级demos">入门级Demos</h1><p>先来几个简单的demo体验一把。注意，例子里ES5的require请通过browserfiy或webpack来实现，如果你还不会用这两样东西，请出门后往前看。</p><h2 id="helloxxx输出">“Hello,XXX”输出</h2><p>ES5写法：</p><pre class="prettyprint"><code class="hljs php has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> React = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"react"</span></span>);<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> HelloMessage = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (&lt;h1&gt;Hello,{this.props.name}!&lt;/h1&gt;);    }});module.exports = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (            &lt;div&gt;                &lt;HelloMessage name = <span class="hljs-string"><span class="hljs-string">"John"</span></span> /&gt;            &lt;/div&gt;        );    }});</code></pre><p>ES6写法：</p><pre class="prettyprint"><code class="hljs axapta has-numbering javascript"><span class="hljs-keyword">import</span> React,{Component} <span class="hljs-keyword">from</span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloMessage</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span>{</span>  <span class="hljs-keyword">constructor</span>() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();  }  render(){    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello {</span><span class="hljs-keyword"><span class="xml">this</span></span><span class="xml">.props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>;</span>  }}<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span>{</span>  <span class="hljs-keyword">constructor</span>() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();  }  render(){    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (      <span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">HelloMessage</span> <span class="hljs-attr">name</span>=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"John"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span>      <span class="hljs-tag">&lt;/</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>    )</span>;  }}<span class="hljs-keyword">export</span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Output;</code></pre><h2 id="数组遍历显示">数组遍历显示</h2><p>ES5写法：</p><pre class="prettyprint"><code class="hljs php has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> React = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"react"</span></span>);<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RepeatArray = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = [<span class="hljs-string"><span class="hljs-string">"Alice"</span></span>, <span class="hljs-string"><span class="hljs-string">"Emily"</span></span>, <span class="hljs-string"><span class="hljs-string">"Kate"</span></span>];        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrs = [            &lt;h1&gt;Hello World&lt;/h1&gt;,            &lt;h2&gt;React is awesome&lt;/h2&gt;        ];        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (            &lt;div&gt;            {arr}            {                names.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function"> </span>{</span><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;Hello, {name}!&lt;/div&gt;;});                 }            &lt;/div&gt;        );    }});module.exports = RepeatArray;</code></pre><p>ES6写法：</p><pre class="prettyprint"><code class="hljs axapta has-numbering coffeescript">import React,{Component} from <span class="hljs-string"><span class="hljs-string">"react"</span></span>;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatArray</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class">{</span></span>  constructor() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();  }  render(){    var arr = [      &lt;h1&gt;Hello world!&lt;/h1&gt;,      &lt;h2&gt;React <span class="hljs-keyword">is</span> awesome&lt;/h2&gt;,    ];    var names = [<span class="hljs-string"><span class="hljs-string">"Alice"</span></span>, <span class="hljs-string"><span class="hljs-string">"Emily"</span></span>, <span class="hljs-string"><span class="hljs-string">"Kate"</span></span>];    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (      &lt;<span class="hljs-keyword">div</span>&gt;      {arr}      {        names.map(<span class="hljs-function"><span class="hljs-params">(name)</span> =&gt;</span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;<span class="hljs-keyword">div</span>&gt;Hello, {name}!&lt;/<span class="hljs-keyword">div</span>&gt;;} )      }      &lt;/<span class="hljs-keyword">div</span>&gt;    );  }}export <span class="hljs-keyword">default</span> RepeatArray;</code></pre><h2 id="ol与li的实现">ol与li的实现</h2><p>ES5写法:</p><pre class="prettyprint"><code class="hljs php has-numbering"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> React = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"react"</span></span>);<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RepeatLi = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(            &lt;ol&gt;                {                    this.props.children.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child)</span></span></span><span class="hljs-function"> </span>{</span>                        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;li&gt;{child}&lt;/li&gt;;                    });                }            &lt;/ol&gt;         );    }});module.exports = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (            &lt;div&gt;                &lt;RepeatLi&gt;                    &lt;span&gt;hello&lt;/span&gt;                    &lt;span&gt;world&lt;/span&gt;                &lt;/RepeatLi&gt;            &lt;/div&gt;        );    }});</code></pre><p>ES6写法：</p><pre class="prettyprint"><code class="hljs axapta has-numbering javascript"><span class="hljs-keyword">import</span> React,{Component} <span class="hljs-keyword">from</span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatLi</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span>{</span>  render(){    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>      {        </span><span class="hljs-keyword"><span class="xml">this</span></span><span class="xml">.props.children.map((child)=&gt;{</span><span class="hljs-keyword"><span class="xml">return</span></span><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{child}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>})      }      <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>    )</span>;  }}<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatArray</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span>{</span>  <span class="hljs-keyword">constructor</span>() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();  }  render(){    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (      <span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">RepeatLi</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">RepeatLi</span>&gt;</span>      <span class="hljs-tag">&lt;/</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>    )</span>;  }}<span class="hljs-keyword">export</span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> RepeatArray;</code></pre><h2 id="click事件">Click事件</h2><p>ES5写法：</p><pre class="prettyprint"><code class="hljs lua has-numbering php"><span class="hljs-keyword">var</span> React = <span class="hljs-built_in"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"react"</span></span>);<span class="hljs-keyword">var</span> MyComponent = React.createClass({    handleClick: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"> </span>{        React.findDOMNode(this.refs.myTextInput).focus();    },    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"> </span>{        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (            &lt;div&gt;                &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> ref=<span class="hljs-string"><span class="hljs-string">"myTextInput"</span></span> /&gt;                &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string"><span class="hljs-string">"button"</span></span> value=<span class="hljs-string"><span class="hljs-string">"Focus the text input"</span></span> onClick= {this.handleClick} /&gt;            &lt;/div&gt;        );    }});<span class="hljs-built_in">module</span>.exports = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"> </span>{        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (            &lt;div&gt;                &lt;MyComponent /&gt;            &lt;/div&gt;        );    }});</code></pre><p>ES6写法：</p><pre class="prettyprint"><code class="hljs axapta has-numbering javascript"><span class="hljs-keyword">import</span> React,{Component} <span class="hljs-keyword">from</span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FocusText</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span>{</span>  handleClick(){    React.findDOMNode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.refs.myText).focus();  }  render(){    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(      <span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> <span class="hljs-attr">ref</span>=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"myText"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"button"</span></span></span></span><span class="xml"><span class="hljs-tag"> <span class="hljs-attr">value</span>=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"focus the text input"</span></span></span></span><span class="xml"><span class="hljs-tag"> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span></span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-string">this</span></span></span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">.handleClick.bind(</span></span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-string">this</span></span></span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">)}</span> /&gt;</span>      <span class="hljs-tag">&lt;/</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>    )</span>;  }}<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatArray</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span>{</span>  <span class="hljs-keyword">constructor</span>() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();  }  render(){    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (      <span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">FocusText</span> /&gt;</span>      <span class="hljs-tag">&lt;/</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>    )</span>;  }}<span class="hljs-keyword">export</span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> RepeatArray;</code></pre><h2 id="state的用法以toggel显示文字为例">State的用法，以toggel显示文字为例</h2><p>ES5写法：</p><pre class="prettyprint"><code class="hljs actionscript has-numbering php"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> React = <span class="hljs-keyword">require</span>(<span class="hljs-string"><span class="hljs-string">"react"</span></span>);<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LikeButton = React.createClass({    getInitialState: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {liked: <span class="hljs-literal"><span class="hljs-keyword">false</span></span>};    },    handleClick: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword">this</span>.setState({liked: !<span class="hljs-keyword">this</span>.state.liked});    },    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = <span class="hljs-keyword">this</span>.state.liked ? <span class="hljs-string"><span class="hljs-string">"like"</span></span> : <span class="hljs-string"><span class="hljs-string">"haven"</span>t liked<span class="hljs-string">"</span></span><span class="hljs-string">;        </span><span class="hljs-keyword"><span class="hljs-string">return</span></span><span class="hljs-string"> (            &lt;p onClick = {</span><span class="hljs-keyword"><span class="hljs-string">this</span></span><span class="hljs-string">.handleClick}&gt;                 You {text} </span><span class="hljs-keyword"><span class="hljs-string">this</span></span><span class="hljs-string">.Click to toggle.            &lt;/p&gt;        );    }});module.exports = React.createClass({    render: </span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-string">function</span></span><span class="hljs-params"><span class="hljs-string">()</span></span><span class="hljs-string"> {</span></span><span class="hljs-string">        </span><span class="hljs-keyword"><span class="hljs-string">return</span></span><span class="hljs-string"> (&lt;div&gt;&lt;LikeButton /&gt;&lt;/div&gt;);    }});</span></code></pre><p>ES6写法：</p><pre class="prettyprint"><code class="hljs axapta has-numbering javascript"><span class="hljs-keyword">import</span> React,{Component} <span class="hljs-keyword">from</span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateUse</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span>{</span>  <span class="hljs-keyword">constructor</span>(){    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state={      <span class="hljs-keyword">like</span>:<span class="hljs-keyword"><span class="hljs-literal">true</span></span>    }  }  handleClick(){    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-keyword">like</span>:!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.<span class="hljs-keyword">like</span>});  }  render(){    <span class="hljs-keyword">var</span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.<span class="hljs-keyword">like</span>?<span class="hljs-string"><span class="hljs-string">"Like"</span></span>:<span class="hljs-string"><span class="hljs-string">"Unlike"</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(      <span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span></span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-string">this</span></span></span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">.handleClick.bind(</span></span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-string">this</span></span></span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">)}</span>&gt;</span>        You {text} </span><span class="hljs-keyword"><span class="xml">this</span></span><span class="xml">.Click the toggle;        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>    )</span>;  }}<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatArray</span></span></span><span class="hljs-class"> </span><span class="hljs-inheritance"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span>{</span>  <span class="hljs-keyword">constructor</span>() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();  }  render(){    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (      <span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">StateUse</span> /&gt;</span>      <span class="hljs-tag">&lt;/</span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span>    )</span>;  }}<span class="hljs-keyword">export</span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> RepeatArray;</code></pre><h2 id="onchange事件以及变量值的同步">onChange事件，以及变量值的同步</h2><p>ES5写法：</p><pre class="prettyprint"><code class="hljs actionscript has-numbering javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string"><span class="hljs-string">"react"</span></span>);<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputComponent = React.createClass({    getInitialState: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params"></span>)</span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {value: <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>};    },    handleChange: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params">e</span>)</span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({value: e.target.value})    },    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params"></span>)</span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.value;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{</span></span></span><span class="hljs-keyword"><span class="xml"><span class="hljs-tag"><span class="hljs-string">this</span></span></span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string">.handleChangle}</span> /&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        )</span>;    }});<span class="hljs-built_in">module</span>.exports = React.createClass({    render: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function">(<span class="hljs-params"></span>)</span></span><span class="hljs-function"> </span>{</span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">InputComponent</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>)</span>    }});</code></pre><p>ES6写法：</p><pre class="prettyprint"><code class="hljs axapta has-numbering javascript"><span class="hljs-keyword">import</span> React,{Component} <span class="hljs-keyword">from</span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>;<span class' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:"http://www.siyuweb.com/wp-content/themes/Ality/img/default.jpg",
        title:'react ',
        describe:'ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍(上) ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍(下) React 示例项目 · 简易留言板 + 待办事项 React 设计思想 ',
        author:"古歌",
        time:"2016-11-18",
        flow:69,
        comments:[],
        enjoy:0,
        id:"7116.html",
        content:'<p><a href="http://blog.csdn.net/a324539017/article/details/52514653">ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍(上)<i class="icon-link"></i></a></p><p><a href="http://blog.csdn.net/a324539017/article/details/52824189">ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍(下)<i class="icon-link"></i></a></p><p><a href="https://github.com/kenberkeley/react-demo">React 示例项目 · 简易留言板 + 待办事项<i class="icon-link"></i></a></p><p><a href="https://github.com/react-guide/react-basic">React 设计思想<i class="icon-link"></i></a></p>	' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:"http://www.siyuweb.com/wp-content/themes/Ality/img/default.jpg",
        title:'古歌react教程笔记 ',
        describe:'古歌react教程笔记 <!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <script src="js/react.js"></script> <script src="js/react-dom.js"></script> <script src="js/browser.min.js"></script> <script src="js/jquery.min.js"></script> <script src="js/marked.m... ',
        author:"古歌",
        time:"2016-09-15",
        flow:228,
        comments:[],
        enjoy:0,
        id:"7117.html",
        content:'	<p>古歌<a href="http://www.siyuweb.com/react">react教程<i class="icon-link"></i></a>笔记</p><pre class="pure-highlightjs"><code class="null hljs xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/react.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/marked.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="xml">//一:ReactDOM.render()ReactDOM.render(  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello,world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>,  document.getElementById("example"));</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="javascript">  <span class="hljs-comment">//demo2 JSX语法</span>  <span class="hljs-comment">//遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。上面代码的运行结果如下。</span><span class="hljs-keyword">var</span> names =[<span class="hljs-string">"alice"</span>,<span class="hljs-string">"emily"</span>,<span class="hljs-string">"kate"</span>];  ReactDOM.render(    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      {        names.map(function(name){          return <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello,{name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        })      }    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>,    document.getElementById("example2")  );</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--//demo3--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="xml"> var arr=[   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>,   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>React is awsome<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> ] ;  ReactDOM.render(    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{arr}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>,    document.getElementById("example3")  );</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--demo4--&gt;</span><span class="hljs-comment">&lt;!--就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example4"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="xml">  var HelloMessage =React.createClass({    render:function(){      return <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{this.props.className}</span>&gt;</span>Hello {this.props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>;    }  });  ReactDOM.render(    <span class="hljs-tag">&lt;<span class="hljs-name">HelloMessage</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"John"</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"ddd"</span>/&gt;</span>,    document.getElementById("example4")  );</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--demo5  this.props.children--&gt;</span><span class="hljs-comment">&lt;!--this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="xml"> var NoteList =React.createClass({   render:function(){     return(       <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>         {           React.Children.map(this.props.children,function(child){             return <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{child}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>           })         }       <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>     )   } }); ReactDOM.render(   <span class="hljs-tag">&lt;<span class="hljs-name">NoteList</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">NoteList</span>&gt;</span>,   document.getElementById("example5") )</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--demo6 PropTypes--&gt;</span><span class="hljs-comment">&lt;!--上面的Mytitle组件有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。现在，我们设置 title 属性的值是一个数值。--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example6"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">var</span> MyTitle = React.createClass({    propTypes:{      title:React.PropTypes.string.isRequired,    },    render:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{this.props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>;</span>    }  });  <span class="hljs-keyword">var</span> data =<span class="hljs-number">123</span>;  ReactDOM.render(    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyTitle</span> <span class="hljs-attr">title</span>=<span class="hljs-string">{data}</span> /&gt;</span>,    document.getElementById("example6")  )</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example6-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">var</span> MyTitle = React.createClass({    getDefaultProps:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{      <span class="hljs-keyword">return</span> {        title:<span class="hljs-string">"Hello world"</span>      };    },    render:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{this.props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>;</span>    }  });  <span class="hljs-keyword">var</span> data =<span class="hljs-number">123</span>;  ReactDOM.render(    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyTitle</span>  /&gt;</span>,    document.getElementById("example6-2")  )</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--demo7获取真实的DOM节点--&gt;</span><span class="hljs-comment">&lt;!--文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example7"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="xml">  var MyComponent = React.createClass({    handleClick:function(){      this.refs.myTextInput.focus();    },    render:function(){      return (        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"myTextInput"</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Focus the text input"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      )    }  });  ReactDOM.render(    <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>/&gt;</span>,    document.getElementById("example7")  )</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--八、this.state--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example8"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="xml">    var LikeButton = React.createClass({      getInitialState:function(){  //方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。        return {liked:false};      },      handleClick:function(){        this.setState({liked:!this.state.liked }); //this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。      },      render:function(){        var text = this.state.liked?"like":"haven"t liked";        return (          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>            You {text} this. click to toggle.          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        );      }    });  ReactDOM.render(    <span class="hljs-tag">&lt;<span class="hljs-name">LikeButton</span>/&gt;</span>,    document.getElementById("example8")  )</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--九、表单--&gt;</span><span class="hljs-comment">&lt;!--文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况，--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example9"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">var</span> Input = React.createClass({    getInitialState:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{      <span class="hljs-keyword">return</span> {value:<span class="hljs-string">"Hello!"</span>};    },    handleChange:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{      <span class="hljs-keyword">this</span>.setState({        value:event.target.value      })    },    render:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{      <span class="hljs-keyword">var</span> value =<span class="hljs-keyword">this</span>.state.value;      <span class="hljs-keyword">return</span> (        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleChange}</span>/&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      )</span>    }  });  ReactDOM.render(    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Input</span> /&gt;</span>,    document.getElementById("example9")  )</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--十、组件的生命周期--&gt;</span><span class="hljs-comment">&lt;!--组件的生命周期分成三个状态：--&gt;</span><span class="hljs-comment">&lt;!--Mounting：已插入真实 DOM--&gt;</span><span class="hljs-comment">&lt;!--Updating：正在被重新渲染--&gt;</span><span class="hljs-comment">&lt;!--Unmounting：已移出真实 DOM--&gt;</span><span class="hljs-comment">&lt;!--hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。--&gt;</span><span class="hljs-comment">&lt;!--React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。--&gt;</span><span class="hljs-comment">&lt;!--componentWillMount()--&gt;</span><span class="hljs-comment">&lt;!--componentDidMount()--&gt;</span><span class="hljs-comment">&lt;!--componentWillUpdate(object nextProps, object nextState)--&gt;</span><span class="hljs-comment">&lt;!--componentDidUpdate(object prevProps, object prevState)--&gt;</span><span class="hljs-comment">&lt;!--componentWillUnmount()--&gt;</span><span class="hljs-comment">&lt;!--此外，React 还提供两种特殊状态的处理函数。--&gt;</span><span class="hljs-comment">&lt;!--componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用--&gt;</span><span class="hljs-comment">&lt;!--shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example10"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">var</span> Hello = React.createClass({    getInitialState:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{      <span class="hljs-keyword">return</span> {        opacity:<span class="hljs-number">1.0</span>      }    },    componentDidMount:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{      <span class="hljs-keyword">this</span>.timer = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        <span class="hljs-keyword">var</span> opacity = <span class="hljs-keyword">this</span>.state.opacity;        opacity -=<span class="hljs-number">.05</span>;        <span class="hljs-keyword">if</span>(opacity&lt;<span class="hljs-number">0.1</span>){          opacity=<span class="hljs-number">1.0</span>        }        <span class="hljs-keyword">this</span>.setState({          opacity:opacity        });      }.bind(<span class="hljs-keyword">this</span>),<span class="hljs-number">100</span>)    },    render:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{     <span class="hljs-comment">//两层{{}}</span>      <span class="hljs-keyword">return</span> (        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{opacity:this.state.opacity}}</span>&gt;</span>          Hello {this.props.name}        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      )</span>    }  });  ReactDOM.render(    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"world"</span>/&gt;</span>,    document.getElementById("example10")  )</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--十一、Ajax--&gt;</span><span class="hljs-comment">&lt;!--组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI （查看 demo11 ）。--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example11"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">var</span> UserGist =React.createClass({      getInitialState:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        <span class="hljs-keyword">return</span>{          username:<span class="hljs-string">""</span>,          lastGistUrl:<span class="hljs-string">""</span>,        }      },      componentDidMount:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        $.get(<span class="hljs-keyword">this</span>.props.source,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>)</span>{          <span class="hljs-keyword">var</span> lastGist = result[<span class="hljs-number">0</span>];          <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isMounted()){            <span class="hljs-keyword">this</span>.setState({              username:lastGist.owner.login,              lastGistUrl:lastGist.html_url            });          }        }.bind(<span class="hljs-keyword">this</span>));      },      render:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{        <span class="hljs-keyword">return</span> (          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>            {this.state.username}"s last gist is            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{this.state.lastGistUrl}</span>&gt;</span>here<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        )</span>;      }    });  ReactDOM.render(    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserGist</span> <span class="hljs-attr">soure</span>=<span class="hljs-string">"https://api.github.com/user/octocat/gists"</span>/&gt;</span>,    document.getElementById("example11")  )</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--demo12--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"example12"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/jsx"</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">var</span> RepoList = React.createClass({    getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{      <span class="hljs-keyword">return</span> { loading: <span class="hljs-literal">true</span>, error: <span class="hljs-literal">null</span>, data: <span class="hljs-literal">null</span>};    },    componentDidMount() {      <span class="hljs-keyword">this</span>.props.promise.then(        value =&gt; <span class="hljs-keyword">this</span>.setState({loading: <span class="hljs-literal">false</span>, data: value}),        error =&gt; <span class="hljs-keyword">this</span>.setState({loading: <span class="hljs-literal">false</span>, error: error}));    },    render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.loading) {        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>;</span>      }      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.error !== <span class="hljs-literal">null</span>) {        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Error: {this.state.error.message}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>;</span>      }      <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">var</span> repos = <span class="hljs-keyword">this</span>.state.data.items;        <span class="hljs-keyword">var</span> repoList = repos.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">repo</span>) </span>{          <span class="hljs-keyword">return</span> (            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{repo.html_url}</span>&gt;</span>{repo.name}<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> ({repo.stargazers_count} stars) <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span> {repo.description}            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>          )</span>;        });        <span class="hljs-keyword">return</span> (          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Most Popular JavaScript Projects in Github<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>{repoList}<span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>        )</span>;      }    }  });  ReactDOM.render(    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">RepoList</span>      <span class="hljs-attr">promise</span>=<span class="hljs-string">{$.getJSON("https:</span>//<span class="hljs-attr">api.github.com</span>/<span class="hljs-attr">search</span>/<span class="hljs-attr">repositories</span>?<span class="hljs-attr">q</span>=<span class="hljs-string">javascript&amp;sort=stars")}</span>    /&gt;</span>,    document.getElementById("example12")  );</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!--&lt;script src="demo.js" type="text/jsx"&gt;&lt;/script&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>ps:http://www.ruanyifeng.com/blog/2015/03/react.html</p>' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:"http://www.siyuweb.com/wp-content/themes/Ality/img/default.jpg",
        title:'React组件生命周期过程 ',
        describe:'实例化 首次实例化 getDefaultProps getInitialState componentWillMount render componentDidMount 实例化完成后的更新 getInitialState componentWillMount render componentDidMount 存在期 组件已存在时的状态改变 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 销毁&清理期 componentWillUnmount 说明 生命周期共提供了10个不同的API... ',
        author:"古歌",
        time:"2016-09-12",
        flow:115,
        comments:[],
        enjoy:0,
        id:"7118.html",
        content:'<h1>实例化</h1><p>首次实例化</p><ul><li>getDefaultProps</li><li>getInitialState</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ul><p>实例化完成后的更新</p><ul><li>getInitialState</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ul><h1>存在期</h1><p>组件已存在时的状态改变</p><ul><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ul><h1>销毁&amp;清理期</h1><ul><li>componentWillUnmount</li></ul><h1>说明</h1><p>生命周期共提供了10个不同的API。</p><h4>1.getDefaultProps</h4><p>作用于组件类，只调用一次，返回对象用于设置默认的<code>props</code>，对于引用值，会在实例中共享。</p><h4>2.getInitialState</h4><p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的<code>state</code>，此时可以访问<code>this.props</code>。</p><h4>3.componentWillMount</h4><p>在完成首次渲染之前调用，此时仍可以修改组件的state。</p><h4>4.render</h4><p>必选的方法，创建虚拟DOM，该方法具有特殊的规则：</p><ul><li>只能通过<code>this.props</code>和<code>this.state</code>访问数据</li><li>可以返回<code>null</code>、<code>false</code>或任何React组件</li><li>只能出现一个顶级组件（不能返回数组）</li><li>不能改变组件的状态</li><li>不能修改DOM的输出</li></ul><h4>5.componentDidMount</h4><p>真实的DOM被渲染出来后调用，在该方法中可通过<code>this.getDOMNode()</code>访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。</p><p><em>在服务端中，该方法不会被调用。</em></p><h4>6.componentWillReceiveProps</h4><p>组件接收到新的<code>props</code>时调用，并将其作为参数<code>nextProps</code>使用，此时可以更改组件<code>props</code>及<code>state</code>。</p><pre><code class="hljs javascript">    componentWillReceiveProps: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nextProps</span>) </span>{        <span class="hljs-keyword">if</span> (nextProps.bool) {            <span class="hljs-keyword">this</span>.setState({                bool: <span class="hljs-literal">true</span>            });        }    }</code></pre><h4>7.shouldComponentUpdate</h4><p>组件是否应当渲染新的<code>props</code>或<code>state</code>，返回<code>false</code>表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。</p><p><em>在首次渲染期间或者调用了<code>forceUpdate</code>方法后，该方法不会被调用</em></p><h4>8.componentWillUpdate</h4><p>接收到新的<code>props</code>或者<code>state</code>后，进行渲染之前调用，此时不允许更新<code>props</code>或<code>state</code>。</p><h4>9.componentDidUpdate</h4><p>完成渲染新的<code>props</code>或者<code>state</code>后调用，此时可以访问到新的DOM元素。</p><h4>10.componentWillUnmount</h4><p>组件被移除之前被调用，可以用于做一些清理工作，在<code>componentDidMount</code>方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。</p><hr><h2>参考资料</h2><ul><li>React：引领未来的用户界面开发框架/寸志 范洪春 杨森 陈涌 译 -- 电子工业出版社</li><li><a href="https://facebook.github.io/react/docs/component-specs.html" rel="nofollow">Component Specs and Lifecycle<span class="badge badge-notification clicks" title="102 次点击">102</span><i class="icon-link"></i></a></li><li>http://react-china.org/t/react/1740</li></ul>' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React",  
        tag:"前端开发",
        images:"http://www.siyuweb.com/wp-content/themes/Ality/img/default.jpg",
        title:'reactjs教程笔记 ',
        describe:'reactjs教程笔记 ps:http://reactjs.cn/react/docs/tutorial-zh-CN.html   <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>React Tutorial</title> <!-- Not present in the tutorial. Just for basic styling. --> <link rel="stylesheet" href="css/base.css"/> <script src="https://cdnjs.cloudflare.com/aj... ',
        author:"古歌",
        time:"2016-09-12",
        flow:152,
        comments:[],
        enjoy:0,
        id:"7119.html",
        content:'<p><a href="http://www.siyuweb.com/react">reactjs教程笔记<i class="icon-link"></i></a></p><p>ps:http://reactjs.cn/react/docs/tutorial-zh-CN.html</p><p>&nbsp;</p><pre class="pure-highlightjs"><code class="null hljs xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>React Tutorial<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-comment">&lt;!-- Not present in the tutorial. Just for basic styling. --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/base.css"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/react/15.0.1/react.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/react/15.0.1/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.16/browser.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/babel"</span>&gt;</span><span class="javascript"><span class="hljs-keyword">var</span> data = [  {id: <span class="hljs-number">1</span>, author: <span class="hljs-string">"Pete Hunt"</span>, text: <span class="hljs-string">"This is one comment"</span>},  {id: <span class="hljs-number">2</span>, author: <span class="hljs-string">"Jordan Walke"</span>, text: <span class="hljs-string">"This is *another* comment"</span>}];<span class="hljs-keyword">var</span> CommentList = React.createClass({  render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">var</span> key=<span class="hljs-number">1</span>;    <span class="hljs-keyword">var</span> commentNodes = <span class="hljs-keyword">this</span>.props.data.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">comment</span>) </span>{      <span class="hljs-keyword">return</span>(        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comment</span> <span class="hljs-attr">key</span> =<span class="hljs-string">{key++}</span> <span class="hljs-attr">author</span>=<span class="hljs-string">{comment.author}</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{comment.id}</span>&gt;</span>          {comment.text}        <span class="hljs-tag">&lt;/<span class="hljs-name">Comment</span>&gt;</span>      )</span>    });    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"CommentList"</span>&gt;</span>        {commentNodes}      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    )</span>  }});<span class="hljs-keyword">var</span> CommentForm = React.createClass({  getInitialState:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    <span class="hljs-keyword">return</span>({      name:<span class="hljs-string">""</span>,      text:<span class="hljs-string">""</span>    })  },  handleNameChange:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{    <span class="hljs-keyword">this</span>.setState({name:e.target.value})  },  handleTextChange:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{    <span class="hljs-keyword">this</span>.setState({text:e.target.value})  },  handleSubmit:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{    e.preventDefault();    <span class="hljs-keyword">var</span> name = <span class="hljs-keyword">this</span>.state.name.trim();    <span class="hljs-keyword">var</span> text = <span class="hljs-keyword">this</span>.state.text.trim();    <span class="hljs-keyword">if</span>(!text || !name){      <span class="hljs-keyword">return</span>;    }    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> send request to the server</span>    <span class="hljs-keyword">this</span>.props.onCommentSubmit({name:name,text:text});    <span class="hljs-keyword">this</span>.setState({      name:<span class="hljs-string">""</span>,      text:<span class="hljs-string">""</span>    })  },  render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"commentForm"</span> <span class="hljs-attr">onSubmit</span> =<span class="hljs-string">{this.handleSubmit}</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleNameChange}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.name}</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleTextChange}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.text}</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Post"</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>    )</span>  }});<span class="hljs-keyword">var</span> Comment = React.createClass({  render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"Comment"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"CommentAuthor"</span>&gt;</span>          {this.props.author}        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>        {this.props.children}      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    )</span>  }});<span class="hljs-keyword">var</span> CommentBox = React.createClass({  loadCommentsFromServer:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    $.ajax({      url: <span class="hljs-keyword">this</span>.props.url,      dataType: <span class="hljs-string">"json"</span>,      cache: <span class="hljs-literal">false</span>,      success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{        <span class="hljs-keyword">this</span>.setState({data: data});      }.bind(<span class="hljs-keyword">this</span>),      error: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xhr, status, err</span>) </span>{        <span class="hljs-built_in">console</span>.error(<span class="hljs-keyword">this</span>.props.url, status, err.toString());      }.bind(<span class="hljs-keyword">this</span>)    });  },  handleCommentSubmit:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">comment</span>)</span>{    <span class="hljs-keyword">var</span> comments = <span class="hljs-keyword">this</span>.state.data;    comment.id = <span class="hljs-built_in">Date</span>.now();    <span class="hljs-keyword">var</span> newComments = comments.concat([comment]);    <span class="hljs-keyword">this</span>.setState({data: newComments});<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> submit to the server and refresh the list</span>    $.ajax({      url: <span class="hljs-keyword">this</span>.props.url,      dataType: <span class="hljs-string">"json"</span>,      type: <span class="hljs-string">"POST"</span>,      data: comment,      success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{        <span class="hljs-keyword">this</span>.setState({data: data});      }.bind(<span class="hljs-keyword">this</span>),      error: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xhr, status, err</span>) </span>{        <span class="hljs-keyword">debugger</span>;        <span class="hljs-keyword">this</span>.setState({data: comments});        <span class="hljs-built_in">console</span>.error(<span class="hljs-keyword">this</span>.props.url, status, err.toString());      }.bind(<span class="hljs-keyword">this</span>)    });  },  getInitialState:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{   <span class="hljs-keyword">return</span> {     data:[]   }  },  componentDidMount:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{   <span class="hljs-comment">//是一个当组件被渲染时被Ｒeact自动调用的方法</span>   <span class="hljs-keyword">this</span>.loadCommentsFromServer();    setInterval(<span class="hljs-keyword">this</span>.loadCommentsFromServer,<span class="hljs-keyword">this</span>.props.pollInterval)  },  render: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"CommentBox"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Comments<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">CommentList</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{this.state.data}</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">CommentForm</span> <span class="hljs-attr">onCommentSubmit</span>=<span class="hljs-string">{this.handleCommentSubmit}</span>/&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    )</span>  }});ReactDOM.render(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CommentBox</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"comments.json"</span> <span class="hljs-attr">pollInterval</span>=<span class="hljs-string">{2000}</span>/&gt;</span>, document.getElementById("content"));</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>&nbsp;</p><p>&nbsp;</p>	' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:"http://www.siyuweb.com/wp-content/themes/Ality/img/default.jpg",
        title:'react学习笔记',
        describe:"react学习笔记,react是前端比较火的一个框架. /** * */ //var a=100; //一个文件是一个模块,a属于模块下的变量 //global.a=200; //console.log(a); //100 //console.log(global.a); //200 //模块加载 //require('模块') //require('./2.js'); //require('e:/www/study/nodejs/module/2.js'); //require('2.js');// 报错 .加载node中的核心模块,或者node_modules /* *1.首先按... ",
        author:"古歌",
        time:"2016-09-05",
        flow:128,
        comments:[],
        enjoy:2,
        id:"7120.html",
        content:'<p><a href="http://www.siyuweb.com/react">react学习<i class="icon-link"></i></a>笔记,react是<a href="http://www.siyuweb.com">前端<i class="icon-link"></i></a>比较火的一个框架.</p><blockquote><pre>/** *  *///var a=100;  //一个文件是一个模块,a属于模块下的变量//global.a=200;//console.log(a); //100//console.log(global.a); //200//模块加载//require("模块")//require("./2.js");//require("e:/www/study/nodejs/module/2.js");//require("2.js");// 报错 .加载node中的核心模块,或者node_modules/* *1.首先按照加载的模块的文件名进行查找,先找到2的文件 * 2.如果没有找到,只在模块文件名称后加上.js的后缀,进行查找 * 3.如果还没有找到,则会在文件名称后面加上json后缀,进行查找 * 4.如果还没有,则会    .node后缀 *文件名称-&gt;.js-&gt;.json-&gt;.node-&gt;报错 *///require("./2");/* *在一个模块中通过var定义的变量,期作用域范围是当前模块,外部不能直接的访问, * 如果我们想一个模块能够访问另一个模块中定义的变量,可以: * 1.把变量作为global对象的一个属性,但是这样的做法不推荐 * 2.使用模块对象 module *///var m3= require("./3");  //返回值是 加载模块中的module.exports//console.log(a); //报错//console.log(module);//console.log(m3);//__filename:当前文件被江西过后的绝对路径//console.log(__filename);//__dirname :当前执行脚本所在目录的目录名。//console.log(__dirname);//setInterval(function(){//    var d=new Date();//    console.log("现在是"+ d.getSeconds());//},1000);//process 全部对象 进程对象//console.log(process);//console.log(global.process);//console.log(process.argv);//console.log(process.env)//console.log(process.pid);//console.log(process.title);//console.log(process.arch);//function log(data){//    process.stdout.write(data); //输出流//}//log("aa");//默认,输入流是关闭的process.stdin.resume();//用于监听用户的输入数据//process.stdin.on("data",function(chunk){//    console.log("用户输入了:"+chunk)//});var a, b;process.stdout.write("清输入a的值"); //输出流process.stdin.on("data", function (chunk) {    if (!a) {        a = Number(chunk);        process.stdout.write("清输入b的值"); //输出流    } else {        b = Number(chunk);        process.stdout.write("a+b值为" + (a + b)); //输出流    }});</pre></blockquote><p>&nbsp;</p><p>3.js</p><blockquote><pre>//var a=88;//global.a=99;/**module: 保存提供和当前模块有关的一些信息*       子对象 exports对象*      通过这个对象把一个模块中的局部变量对象进行提供访问 *///console.log(module);//module.exports.a = 66;/**在模块作用域,还有一个内置的模块对象,exports,其实是module.exports* 上面的赋值 等于 下面 */exports.a = 66;console.log(module.exports === exports);module.exports=[1,2,3]; //exports 和  module.exports 的指向关系已经断开,不推荐exports = [1,2,3];  //exports 和  module.exports 的指向关系已经断开,不推荐exports.a=200;  //不起作用</pre></blockquote><p>&nbsp;</p><p>Buffer:</p><blockquote><pre>//encoding String类型, 可选参数, 默认: "utf8"//start Number类型, 可选参数, 默认: 0//end Number类型, 可选参数, 默认: buffer.length//new Buffer(array);//var bf = new Buffer([1,2,3]);//console.log(bf);//bf[10]=10;//console.log(bf);//new Buffer(string，[encoding]);//var bf = new Buffer("miaov","utf-8");//console.log(bf);//for(var i=0;i&lt;bf.length;i++){//   // console.log(bf[i].toString(16));//    console.log(String.fromCharCode(bf[i]))//}//var str1 = "miaov";//var bf1=new Buffer(str1);//console.log(str1.length);//console.log(bf1.length);////var str2 = "秒味";//var bf2=new Buffer(str2);//console.log(str2.length);//console.log(bf2.length);////var str3 = "miaov";//var bf3=new Buffer(str3);////bf3.write(str3);//console.log(bf3);//var bf3  = new Buffer(3);//console.log(bf3);//bf3.write(str3,1,3);//console.log(bf3);////var bf4=new Buffer("miaov");//console.log(bf4.toString());//console.log(bf4.toString("utf-8",1,3));////var bf5= new Buffer("秒味");//console.log(bf5);//console.log(bf5.toString("utf-8",1));////console.log(bf5.toJSON());////var bf6 =bf4.slice(2);//bf6[0]=2;//console.log(bf6);//console.log(bf4);//var bf4=new Buffer("miaov");//var bf7 = new Buffer(10);//bf4.copy(bf7);//console.log(bf7);//bf4.copy(bf7,1);////console.log(bf7);//bf4[0]=2;//console.log(bf7);//console.log(bf4);//console.log(Buffer.isEncoding("utf-8"))//var arr=[1,2,3];//var bf = new Buffer(10);//console.log(Buffer.isBuffer(arr));//console.log(Buffer.isBuffer(bf));////var str= "miaov";//console.log(str.length);//console.log(Buffer.byteLength(str));////var str2= "秒味";//console.log(str2.length);//console.log(Buffer.byteLength(str2));////var list= [new Buffer(str),new Buffer(str2)];//console.log(list);////var bf= Buffer.concat(list,11);//console.log(bf);////process.stdout.write("清输入内容:");//process.stdin.resume();//process.stdin.on("data",function(chunk){//    console.log(chunk);//    console.log(chunk.toString());//});</pre></blockquote><p>&nbsp;</p><p>fs:</p><blockquote><pre>//fs模块var fs =require("fs");/* fs.open(path,flags.[mode],callback) path:要打开的文件的路径 flags:打开文件的方式 读/写 mode:设置文件的模式 读/写/执行  4/2/1 callback:回调 err:文件打开失败的错误保存在err里面,如果成功,errwei null fd:被打开的文件的标示.和 定时器标示相似 //再次打开时fd会累加 *///fs.open("1","r",function(err,fd){//    console.log(err);//    console.log(fd);//    if(err){//        console.log("文件打开失败!")//    }else{//        console.log("文件开成功");//        console.log(fd)//    }//});//同步异步//fs.open("1","r",function(err,fd){//    console.log(err);//});//console.log("ok");var fd = fs.openSync("1","r");console.log(fd);</pre></blockquote><p>&nbsp;</p>' 
    },
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:"https://pic2.zhimg.com/80/v2-8ab3ae3d0389a3db3a9fba7b59d07805_hd.jpg",
        title:' 可能是你见过最完善的微前端解决方案',
        describe:'目前社区有很多关于微前端架构的介绍，但大多停留在概念介绍的阶段。而本文会就某一个具体的类型场景，着重介绍微前端架构可以带来什么价值以及具体实践过程中需要关注的技术决策，并辅以具体代码，从而能真正意义上帮助你构建一个生产可用的微前端架构系统。 而对于微前端的概念感兴趣或不熟悉的同学...',
        author:"古歌",
        time:" 2019-08-30",
        flow:7,
        comments:[],
        enjoy:0,
        id:"7121.html",
        content:'			<p>目前社区有很多关于微前端架构的介绍，但大多停留在概念介绍的阶段。而本文会就某一个具体的类型场景，着重介绍微前端架构可以<b>带来什么价值</b>以及<b>具体实践过程中需要关注的技术决策</b>，并辅以具体代码，从而能真正意义上帮助你构建一个<b>生产可用</b>的微前端架构系统。</p><p>而对于微前端的概念感兴趣或不熟悉的同学，可以通过搜索引擎来获取更多信息，如&nbsp;<a class="internal" href="https://www.zhihu.com/search?q=%E5%BE%AE%E5%89%8D%E7%AB%AF&amp;type=content" data-za-detail-view-id="1043">知乎上的相关内容</a>， 本文不再做过多介绍。</p><p><i>两个月前 Twitter 曾爆发过关于微前端的“热烈”讨论，参与大佬众多(Dan、Larkin 等)，对“事件”本身我们今天不做过多评论(后面可能会写篇文章来回顾一下)，有兴趣的同学可以通过</i><a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//zendev.com/2019/06/17/microfrontends-good-bad-ugly.html" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">这篇文章</a><i>了解一二。</i></p><h2>微前端的价值</h2><p>微前端架构具备以下几个核心价值：</p><ul><li>技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权</li><li>独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li><li>独立运行时 每个子应用之间状态隔离，运行时状态不共享</li></ul><p>微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DpU1gXA0rfwc" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">Frontend Monolith</a>)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。</p><h2>针对中后台应用的解决方案</h2><p>中后台应用由于其应用生命周期长(动辄 3+ 年)等特点，最后演变成一个巨石应用的概率往往高于其他类型的 web 应用。而从技术实现角度，微前端架构解决方案大概分为两类场景：</p><ul><li>单实例：即同一时刻，只有一个子应用被展示，子应用具备一个完整的应用生命周期。通常基于 url 的变化来做子应用的切换。</li><li>多实例：同一时刻可展示多个子应用。通常使用 Web Components 方案来做子应用封装，子应用更像是一个业务组件而不是应用。</li></ul><p>本文将着重介绍<b>单实例场景</b>下的微前端架构实践方案（基于&nbsp;<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//github.com/CanopyTax/single-spa" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">single-spa</a>），因为这个场景更贴近大部分中后台应用。</p><h2>行业现状</h2><p>传统的云控制台应用，几乎都会面临业务快速发展之后，单体应用进化成巨石应用的问题。为了解决产品研发之间各种耦合的问题，大部分企业也都会有自己的解决方案。笔者于17年底，针对国内外几个著名的云产品控制台，做过这样一个技术调研：</p><figure data-size="normal"><img data-tag="bdshare" class="origin_image zh-lightbox-thumb lazy" src="https://pic2.zhimg.com/80/v2-8ab3ae3d0389a3db3a9fba7b59d07805_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1620" data-rawheight="882" data-original="https://pic2.zhimg.com/v2-8ab3ae3d0389a3db3a9fba7b59d07805_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-8ab3ae3d0389a3db3a9fba7b59d07805_b.jpg" data-lazy-status="ok" width="1620"></figure><p>MPA 方案的优点在于 部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。</p><p>SPA 则天生具备体验上的优势，应用直接无刷新切换，能极大的保证多产品之间流程操作串联时的流程性。缺点则在于各应用技术栈之间是强耦合的。</p><p>那我们有没有可能将 MPA 和 SPA 两者的优势结合起来，构建出一个相对完善的微前端架构方案呢？</p><p><i>jsconf china 2016 大会上，ucloud 的同学分享了他们的基于 angularjs 的方案（</i><a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DyL_znMNwTNw" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">单页应用“联邦制”实践</a><i>），里面提到的 “联邦制” 概念很贴切，可以认为是早期的基于耦合技术栈的微前端架构实践。</i></p><h2>微前端架构实践中的问题</h2><p>可以发现，微前端架构的优势，正是 MPA 与 SPA 架构优势的合集。即保证应用具备独立开发权的同时，又有将它们整合到一起保证产品完整的流程体验的能力。</p><p>这样一套模式下，应用的架构就会变成：</p><figure data-size="normal"><img data-tag="bdshare" class="origin_image zh-lightbox-thumb lazy" src="https://pic1.zhimg.com/80/v2-49e29d35de9548c02b0d48782714e914_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1600" data-rawheight="1427" data-original="https://pic1.zhimg.com/v2-49e29d35de9548c02b0d48782714e914_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-49e29d35de9548c02b0d48782714e914_b.jpg" data-lazy-status="ok" width="1600"></figure><p>Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：<b>导航路由 + 资源加载框架</b>。</p><p>而具体要实现这样一套架构，我们需要解决以下几个技术问题：</p><h3>路由系统及 Future State</h3><p>我们在一个实现了微前端内核的产品中，正常访问一个子应用的页面时，可能会有这样一个链路：</p><figure data-size="normal"><img data-tag="bdshare" class="origin_image zh-lightbox-thumb lazy" src="https://pic2.zhimg.com/80/v2-fd275bb861de03f4aa9f9656d6a4c989_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1578" data-rawheight="1020" data-original="https://pic2.zhimg.com/v2-fd275bb861de03f4aa9f9656d6a4c989_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-fd275bb861de03f4aa9f9656d6a4c989_b.jpg" data-lazy-status="ok" width="1578"></figure><p>此时浏览器的地址可能是&nbsp;<code>https://app.alipay.com/subApp/123/detail</code>，想象一下，此时我们手动刷新一下浏览器，会发生什么情况？</p><p>由于我们的子应用都是 lazy load 的，当浏览器重新刷新时，主框架的资源会被重新加载，同时异步 load 子应用的静态资源，由于此时主应用的路由系统已经激活，但子应用的资源可能还没有完全加载完毕，从而导致路由注册表里发现没有能匹配子应用&nbsp;<code>/subApp/123/detail</code>&nbsp;的规则，这时候就会导致跳 NotFound 页或者直接路由报错。</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-adsbygoogle-status="done" data-ad-client="ca-pub-0608155192548477" class="adsbygoogle adsbygoogle-noablate" data-ad-format="auto" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_4_expand" style="display:inline-table;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><ins id="aswift_4_anchor" style="display:block;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_4" name="aswift_4" style="left:0;position:absolute;top:0;border:0px;width:613px;height:154px;" frameborder="0" height="154" width="613"></iframe></ins></ins></ins></div><p>这个问题在所有 lazy load 方式加载子应用的方案中都会碰到，早些年前 angularjs 社区把这个问题统一称之为&nbsp;<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//ui-router.github.io/guide/lazyloading%23future-states" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">Future State</a>。</p><p>解决的思路也很简单，我们需要设计这样一套路由机制：</p><p>主框架配置子应用的路由为&nbsp;<code>subApp: { url: "/subApp/**", entry: "./subApp.js" }</code>，则当浏览器的地址为&nbsp;<code>/subApp/abc</code>&nbsp;时，框架需要先加载 entry 资源，待 entry 资源加载完毕，确保子应用的路由系统注册进主框架之后后，再去由子应用的路由系统接管 url change 事件。同时在子应用路由切出时，主框架需要触发相应的 destroy 事件，子应用在监听到该事件时，调用自己的卸载方法卸载应用，如 React 场景下&nbsp;<code>destroy = () =&gt; ReactDOM.unmountAtNode(container)</code>。</p><p>要实现这样一套机制，我们可以自己去劫持 url change 事件从而实现自己的路由系统，也可以基于社区已有的 ui router library，尤其是 react-router 在 v4 之后实现了&nbsp;<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//reacttraining.com/react-router/core/guides/philosophy" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">Dynamic Routing</a>&nbsp;能力，我们只需要复写一部分路由发现的逻辑即可。这里我们推荐直接选择社区比较完善的相关实践&nbsp;<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//github.com/CanopyTax/single-spa" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">single-spa</a>。</p><h3>App Entry</h3><p>解决了路由问题后，主框架与子应用集成的方式，也会成为一个需要重点关注的技术决策。</p><h3>构建时组合 VS 运行时组合</h3><p>微前端架构模式下，子应用打包的方式，基本分为两种：</p><figure data-size="normal"><img data-tag="bdshare" class="origin_image zh-lightbox-thumb lazy" src="https://pic2.zhimg.com/80/v2-aa016d5969d2cabd2de02dada37ae195_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1622" data-rawheight="354" data-original="https://pic2.zhimg.com/v2-aa016d5969d2cabd2de02dada37ae195_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-aa016d5969d2cabd2de02dada37ae195_b.jpg" data-lazy-status="ok" width="1622"></figure><p>两者的优缺点也很明显：</p><figure data-size="normal"><img data-tag="bdshare" class="origin_image zh-lightbox-thumb lazy" src="https://pic2.zhimg.com/80/v2-b16657fad054d4816c62f2bea1437951_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1620" data-rawheight="500" data-original="https://pic2.zhimg.com/v2-b16657fad054d4816c62f2bea1437951_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-b16657fad054d4816c62f2bea1437951_b.jpg" data-lazy-status="ok" width="1620"></figure><p>很显然，要实现真正的技术栈无关跟独立部署两个核心目标，大部分场景下我们需要使用运行时加载子应用这种方案。</p><h3>JS Entry vs HTML Entry</h3><p>在确定了运行时载入的方案后，另一个需要决策的点是，我们需要子应用提供什么形式的资源作为渲染入口？</p><p>JS Entry 的方式通常是子应用将资源打成一个 entry script，比如 single-spa 的&nbsp;<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//github.com/joeldenning/simple-single-spa-webpack-example/blob/master/src/root-application/root-application.js" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">example</a>&nbsp;中的方式。但这个方案的限制也颇多，如要求子应用的所有资源打包到一个 js bundle 里，包括 css、图片等资源。除了打出来的包可能体积庞大之外的问题之外，资源的并行加载等特性也无法利用上。</p><p>HTML Entry 则更加灵活，直接将子应用打出来 HTML 作为入口，主框架可以通过 fetch html 的方式获取子应用的静态资源，同时将 HTML document 作为子节点塞到主框架的容器中。这样不仅可以极大的减少主应用的接入成本，子应用的开发方式及打包方式基本上也不需要调整，而且可以天然的解决子应用之间样式隔离的问题(后面提到)。想象一下这样一个场景：</p><div class="highlight"><pre><code class="language-html"><span class="c">&lt;!-- 子应用 index.html --&gt;</span><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">"//unpkg/antd.min.js"</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>  <span class="p">&lt;</span><span class="nt">main</span> <span class="na">id</span><span class="o">=</span><span class="s">"root"</span><span class="p">&gt;&lt;/</span><span class="nt">main</span><span class="p">&gt;</span><span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>// 子应用入口ReactDOM.render(<span class="p">&lt;</span><span class="nt">App</span><span class="p">/&gt;</span>, document.getElementById("root"))</code></pre></div><p>如果是 JS Entry 方案，主框架需要在子应用加载之前构建好相应的容器节点(比如这里的 “#root” 节点)，不然子应用加载时会因为找不到 container 报错。但问题在于，主应用并不能保证子应用使用的容器节点为某一特定标记元素。而 HTML Entry 的方案则天然能解决这一问题，保留子应用完整的环境上下文，从而确保子应用有良好的开发体验。</p><p>HTML Entry 方案下，主框架注册子应用的方式则变成：</p><div class="highlight"><pre><code class="language-js"><span class="nx">framework</span><span class="p">.</span><span class="nx">registerApp</span><span class="p">(</span><span class="s1">"subApp1"</span><span class="p">,</span> <span class="p">{</span> <span class="nx">entry</span><span class="o">:</span> <span class="s1">'//abc.alipay.com/index.html'</span><span class="p">})</span></code></pre></div><p>本质上这里 HTML 充当的是应用静态资源表的角色，在某些场景下，我们也可以将 HTML Entry 的方案优化成 Config Entry，从而减少一次请求，如：</p><div class="highlight"><pre><code class="language-js"><span class="nx">framework</span><span class="p">.</span><span class="nx">registerApp</span><span class="p">(</span><span class="s1">'subApp1'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">html</span><span class="o">:</span> <span class="s1">''</span><span class="p">,</span> <span class="nx">scripts</span><span class="o">:</span> <span class="p">[</span><span class="s1">'//abc.alipay.com/index.js'</span><span class="p">],</span> <span class="nx">css</span><span class="o">:</span> <span class="p">[</span><span class="s1">'//abc.alipay.com/index.css'</span><span class="p">]})</span></code></pre></div><p>总结一下：</p><figure data-size="normal"><img data-tag="bdshare" class="origin_image zh-lightbox-thumb lazy" src="https://pic1.zhimg.com/80/v2-dde4d233b0b55039ad309dfb2db0a5d4_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1628" data-rawheight="668" data-original="https://pic1.zhimg.com/v2-dde4d233b0b55039ad309dfb2db0a5d4_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-dde4d233b0b55039ad309dfb2db0a5d4_b.jpg" data-lazy-status="ok" width="1628"></figure><h3>模块导入</h3><p>微前端架构下，我们需要获取到子应用暴露出的一些钩子引用，如 bootstrap、mount、unmout 等(参考 single-spa)，从而能对接入应用有一个完整的生命周期控制。而由于子应用通常又有集成部署、独立部署两种模式同时支持的需求，使得我们只能选择 umd 这种兼容性的模块格式打包我们的子应用。如何在浏览器运行时获取远程脚本中导出的模块引用也是一个需要解决的问题。</p><p>通常我们第一反应的解法，也是最简单的解法就是与子应用与主框架之间约定好一个全局变量，把导出的钩子引用挂载到这个全局变量上，然后主应用从这里面取生命周期函数。</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-adsbygoogle-status="done" data-ad-client="ca-pub-0608155192548477" class="adsbygoogle adsbygoogle-noablate" data-ad-format="auto" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display:inline-table;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><ins id="aswift_5_anchor" style="display:block;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;border:0px;width:613px;height:154px;" frameborder="0" height="154" width="613"></iframe></ins></ins></ins></div><p>这个方案很好用，但是最大的问题是，主应用与子应用之间存在一种强约定的打包协议。那我们是否能找出一种松耦合的解决方案呢？</p><p>很简单，我们只需要走 umd 包格式中的 global export 方式获取子应用的导出即可，大体的思路是通过给 window 变量打标记，记住每次最后添加的全局变量，这个变量一般就是应用 export 后挂载到 global 上的变量。实现方式可以参考&nbsp;<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//github.com/systemjs/systemjs/blob/master/src/extras/global.js" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">systemjs global import</a>，这里不再赘述。</p><h3>应用隔离</h3><p>微前端架构方案中有两个非常关键的问题，有没有解决这两个问题将直接标志你的方案是否真的生产可用。比较遗憾的是此前社区在这个问题上的处理都会不约而同选择”绕道“的方式，比如通过主子应用之间的一些默认约定去规避冲突。而今天我们会尝试从纯技术角度，更智能的解决应用之间可能冲突的问题。</p><h3>样式隔离</h3><p>由于微前端场景下，不同技术栈的子应用会被集成到同一个运行时中，所以我们必须在框架层确保各个子应用之间不会出现样式互相干扰的问题。</p><h3>Shadow DOM？</h3><p>针对 “Isolated Styles” 这个问题，如果不考虑浏览器兼容性，通常第一个浮现到我们脑海里的方案会是 Web Components。基于 Web Components 的 Shadow DOM 能力，我们可以将每个子应用包裹到一个 Shadow DOM 中，保证其运行时的样式的绝对隔离。</p><p>但 Shadow DOM 方案在工程实践中会碰到一个常见问题，比如我们这样去构建了一个在 Shadow DOM 里渲染的子应用：</p><div class="highlight"><pre><code class="language-js"><span class="k">const</span> <span class="nx">shadow</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'#hostElement'</span><span class="p">).</span><span class="nx">attachShadow</span><span class="p">({</span><span class="nx">mode</span><span class="o">:</span> <span class="s1">'open'</span><span class="p">});</span><span class="nx">shadow</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s1">'&lt;sub-app&gt;Here is some new text&lt;/sub-app&gt;&lt;link rel="stylesheet" href="//unpkg.com/antd/antd.min.css"&gt;'</span><span class="p">;</span></code></pre></div><p>由于子应用的样式作用域仅在 shadow 元素下，那么一旦子应用中出现运行时越界跑到外面构建 DOM 的场景，必定会导致构建出来的 DOM 无法应用子应用的样式的情况。</p><p>比如 sub-app 里调用了 antd modal 组件，由于 modal 是动态挂载到 document.body 的，而由于 Shadow DOM 的特性 antd 的样式只会在 shadow 这个作用域下生效，结果就是弹出框无法应用到 antd 的样式。解决的办法是把 antd 样式上浮一层，丢到主文档里，但这么做意味着子应用的样式直接泄露到主文档了。gg…</p><h3>CSS Module? BEM?</h3><p>社区通常的实践是通过约定 css 前缀的方式来避免样式冲突，即各个子应用使用特定的前缀来命名 class，或者直接基于 css module 方案写样式。对于一个全新的项目，这样当然是可行，但是通常微前端架构更多的目标是解决存量/遗产 应用的接入问题。很显然遗产应用通常是很难有动力做大幅改造的。</p><p>最主要的是，约定的方式有一个无法解决的问题，假如子应用中使用了三方的组件库，三方库在写入了大量的全局样式的同时又不支持定制化前缀？比如 a 应用引入了 antd 2.x，而 b 应用引入了 antd 3.x，两个版本的 antd 都写入了全局的&nbsp;<code>.menu class</code>，但又彼此不兼容怎么办？</p><h3>Dynamic Stylesheet !</h3><p>解决方案其实很简单，我们只需要在应用切出/卸载后，同时卸载掉其样式表即可，原理是浏览器会对所有的样式表的插入、移除做整个 CSSOM 的重构，从而达到 插入、卸载 样式的目的。这样即能保证，在一个时间点里，只有一个应用的样式表是生效的。</p><p>上文提到的 HTML Entry 方案则天生具备样式隔离的特性，因为应用卸载后会直接移除去 HTML 结构，从而自动移除了其样式表。</p><p>比如 HTML Entry 模式下，子应用加载完成的后的 DOM 结构可能长这样：</p><div class="highlight"><pre><code class="language-html"><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>    <span class="p">&lt;</span><span class="nt">main</span> <span class="na">id</span><span class="o">=</span><span class="s">"subApp"</span><span class="p">&gt;</span>      // 子应用完整的 html 结构      <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">"stylesheet"</span> <span class="na">href</span><span class="o">=</span><span class="s">"//alipay.com/subapp.css"</span><span class="p">&gt;</span>      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"root"</span><span class="p">&gt;</span>....<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>    <span class="p">&lt;/</span><span class="nt">main</span><span class="p">&gt;</span>  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span><span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span></code></pre></div><p>当子应用被替换或卸载时，<code>subApp</code>&nbsp;节点的 innerHTML 也会被复写，<code>//alipay.com/subapp.css</code>&nbsp;也就自然被移除样式也随之卸载了。</p><h3>JS 隔离</h3><p>解决了样式隔离的问题后，有一个更关键的问题我们还没有解决：如何确保各个子应用之间的全局变量不会互相干扰，从而保证每个子应用之间的软隔离？</p><p>这个问题比样式隔离的问题更棘手，社区的普遍玩法是给一些全局副作用加各种前缀从而避免冲突。但其实我们都明白，这种通过团队间的”口头“约定的方式往往低效且易碎，所有依赖人为约束的方案都很难避免由于人的疏忽导致的线上 bug。那么我们是否有可能打造出一个好用的且完全无约束的 JS 隔离方案呢？</p><p>针对 JS 隔离的问题，我们独创了一个运行时的 JS 沙箱。简单画了个架构图：</p><figure data-size="normal"><img data-tag="bdshare" class="origin_image zh-lightbox-thumb lazy" src="https://pic1.zhimg.com/80/v2-b98e3a5036fb61f14262f7984ed22810_hd.jpg" data-caption="" data-size="normal" data-rawwidth="582" data-rawheight="534" data-original="https://pic1.zhimg.com/v2-b98e3a5036fb61f14262f7984ed22810_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b98e3a5036fb61f14262f7984ed22810_b.jpg" data-lazy-status="ok" width="582"></figure><p>即在应用的 bootstrap 及 mount 两个生命周期开始之前分别给全局状态打下快照，然后当应用切出/卸载时，将状态回滚至 bootstrap 开始之前的阶段，确保应用对全局状态的污染全部清零。而当应用二次进入时则再恢复至 mount 前的状态的，从而确保应用在 remount 时拥有跟第一次 mount 时一致的全局上下文。</p><p>当然沙箱里做的事情还远不止这些，其他的还包括一些对全局事件监听的劫持等，以确保应用在切出之后，对全局事件的监听能得到完整的卸载，同时也会在 remount 时重新监听这些全局事件，从而模拟出与应用独立运行时一致的沙箱环境。</p><h2>蚂蚁的微前端落地实践</h2><p>自去年年底伊始，我们便尝试基于微前端架构模式，构建出一套全链路的面向中后台场景的产品接入平台，目的是解决不同产品之间集成困难、流程割裂的问题，希望接入平台后的应用，不论使用哪种技术栈，在运行时都可以通过自定义配置，实现不同应用之间页面级别的自由组合，从而生成一个千人千面的个性化控制台。</p><p>目前这套平台已在蚂蚁生产环境运行半年多，同时接入了多个产品线的 40+ 应用、4+ 不同类型的技术栈。过程中针对大量微前端实践中的问题，我们总结出了一套完整的解决方案：</p><figure data-size="normal"><img data-tag="bdshare" class="origin_image zh-lightbox-thumb lazy" src="https://pic2.zhimg.com/80/v2-d55549366b52cde19c93835cfa2a58c9_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1558" data-rawheight="1176" data-original="https://pic2.zhimg.com/v2-d55549366b52cde19c93835cfa2a58c9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-d55549366b52cde19c93835cfa2a58c9_b.jpg" data-lazy-status="ok" width="1558"></figure><p>在内部得到充分的技术验证和线上考验之后，我们决定将这套解决方案开源出来！</p><h3>qiankun – 一套完整的微前端解决方案</h3><p><b><a class=" external" href="https://link.zhihu.com/?target=https%3A//github.com/umijs/qiankun" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043"><span class="invisible">https://</span><span class="visible">github.com/umijs/qianku</span><span class="invisible">n</span></a></b></p><p>取名 qiankun，意为统一。我们希望通过 qiankun 这种技术手段，让你能很方便的将一个巨石应用改造成一个基于微前端架构的系统，并且不再需要去关注各种过程中的技术细节，做到真正的开箱即用和生产可用。</p><p>对于 umi 用户我们也提供了配套的 qiankun 插件&nbsp;<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//github.com/umijs/umi-plugin-qiankun/" target="_blank" rel="nofollow noopener noreferrer" data-za-detail-view-id="1043">@umijs/plugin-qiankun</a>&nbsp;，以便于 umi 应用能几乎零成本的接入 qiankun。</p><p>最后欢迎大家点赞使用提出宝贵的意见。�</p><div class="ContentItem-time">编辑于 2019-08-16</div>' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React",  
        tag:"前端开发",
        images:"http://img.yyyweb.com/uploads/2016/10/281255474349914-240x180.jpg",
        title:' Vue.js vs React vs Angular 深度对比',
        describe:'这个页面无疑是最难编写的，但我们认为它也是非常重要的。或许你曾遇到了一些问题并且已经用其他的框架解决了。你来这里的目的是看看 Vue 是否有更好的解决方案。这也是我们在此想要回答的。 客观来说，作为核心团队成员，显然我们会更偏爱 Vue，认为对于某些问题来讲用 Vue 解决会更好...',
        author:"古歌",
        time:"2016-11-20",
        flow:10845,
        comments:[],
        enjoy:53,
        id:"7122.html",
        content:'<p style="color: #34495e;">这个页面无疑是最难编写的，但我们认为它也是非常重要的。或许你曾遇到了一些问题并且已经用其他的框架解决了。你来这里的目的是看看 Vue 是否有更好的解决方案。这也是我们在此想要回答的。</p><p style="color: #34495e;">客观来说，作为核心团队成员，显然我们会更偏爱 Vue，认为对于某些问题来讲用 Vue 解决会更好。如果没有这点信念，我们也就不会整天为此忙活了。但是在此，我们想尽可能地公平和准确地来描述一切。其他的框架也有显著的优点，例如 React 庞大的生态系统，或者像是 Knockout 对浏览器的支持覆盖到了 IE6。我们会尝试着把这些内容全部列出来。</p><p style="color: #34495e;">我们也希望得到<span style="font-weight: 600; color: #2c3e50;">你</span>的帮助，来使文档保持最新状态，因为 JavaScript 的世界进步的太快。如果你注意到一个不准确或似乎不太正确的地方，请<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide" target="_blank" rel="external">提交问题</a>让我们知道。</p><h2 id="React" style="font-weight: 600; color: #2c3e50;">React</h2><p style="color: #34495e;">React 和 Vue 有许多相似之处，它们都有：</p><ul style="color: #34495e;"><li>使用 Virtual DOM</li><li>提供了响应式（Reactive）和组件化（Composable）的视图组件。</li><li>将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。</li></ul><p style="color: #34495e;">由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要指出 React 比 Vue 更好的地方，像是他们的生态系统和丰富的自定义渲染器。</p><p style="color: #34495e;">React社区为我们准确进行平衡的考量提供了<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vuejs.org/issues/364" target="_blank" rel="external">非常积极地帮助</a>，特别感谢来自 React 团队的 Dan Abramov 。他非常慷慨的花费时间来贡献专业知识，帮助我们完善这篇文档，最后我们对最终结果<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244575740" target="_blank" rel="external">都十分满意</a>。</p><h3 id="性能简介" style="color: #2c3e50;">性能简介</h3><p style="color: #34495e;">到目前为止，针对现实情况的测试中，Vue 的性能是优于 React 的。如果你对此表示怀疑，请继续阅读。我们会解释为什么会这样（并且会提供一个与 React 团队共同约定的比较基准）。</p><h4 id="渲染性能" style="color: #2c3e50;">渲染性能</h4><p style="color: #34495e;">在渲染用户界面的时候，DOM 的操作成本是最高的，不幸的是没有库可以让这些原始操作变得更快。<br>我们能做到的最好效果就是：</p><ol style="color: #34495e;"><li>Minimize the number of necessary DOM mutations. Both React and Vue use virtual DOM abstractions to accomplish this and both implementations work about equally well.</li><li>Add as little overhead (pure JavaScript computations) as possible on top of those DOM manipulations. This is an area where Vue and React differ.</li></ol><p style="color: #34495e;">The JavaScript overhead is directly related to the mechanisms of computing the necessary DOM operations. Both Vue and React utilizes Virtual DOM to achieve that, but Vue’s Virtual DOM implementation (a fork of&nbsp;<a style="font-weight: 600; color: #42b983;" href="https://github.com/snabbdom/snabbdom" target="_blank" rel="external">snabbdom</a>) is much lighter-weight and thus introduces less overhead than React’s.</p><p style="color: #34495e;">Vue 和 React 也提供功能性组件，这些组件因为都是没有声明，没有实例化的，因此会花费更少的开销。当这些都用于关键性能的场景时，Vue 将会更快。为了证明这点，我们建立了一个简单的<a style="font-weight: 600; color: #42b983;" href="https://github.com/chrisvfritz/vue-render-performance-comparisons" target="_blank" rel="external">参照项目</a>，它负责渲染 10,000 个列表项 100 次。我们鼓励你基于此去尝试运行一下。然而在实际上，由于浏览器和硬件的差异甚至 JavaScript 引擎的不同，结果都会相应有所不同。</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-adsbygoogle-status="done" data-ad-client="ca-pub-0608155192548477" class="adsbygoogle adsbygoogle-noablate" data-ad-format="auto" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_4_expand" style="display:inline-table;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><ins id="aswift_4_anchor" style="display:block;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_4" name="aswift_4" style="left:0;position:absolute;top:0;border:0px;width:613px;height:154px;" frameborder="0" height="154" width="613"></iframe></ins></ins></ins></div><p style="color: #34495e;">如果你懒得去做，下面的数值是来自于一个 2014 年产的 MacBook Air 并在 Chrome 52 版本下运行所产生的。为了避免偶然性，每个参照项目都分别运行 20 次并取自最好的结果：</p><table class="benchmark-table" style="color: #34495e;"><thead><tr><th></th><th>Vue</th><th>React</th></tr></thead><tbody><tr><th>Fastest</th><td>23ms</td><td>63ms</td></tr><tr><th>Median</th><td>42ms</td><td>81ms</td></tr><tr><th>Average</th><td>51ms</td><td>94ms</td></tr><tr><th>95th Perc.</th><td>73ms</td><td>164ms</td></tr><tr><th>Slowest</th><td>343ms</td><td>453ms</td></tr></tbody></table><h4 id="更新性能" style="color: #2c3e50;">更新性能</h4><p style="color: #34495e;">In React, when a component’s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root.</p><p style="color: #34495e;">To avoid unnecessary re-renders of child components, you need to implement<code style="color: #e96900;">shouldComponentUpdate</code>&nbsp;everywhere and use immutable data structures. In Vue, a component’s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render.</p><p style="color: #34495e;">这意味着，未经优化的 Vue 相比未经优化的 React 要快的多。由于 Vue 改进过渲染性能，甚至全面优化过的 React 通常也会慢于开箱即用的 Vue。</p><h4 id="开发中" style="color: #2c3e50;">开发中</h4><p style="color: #34495e;">显然，在生产环境中的性能是至关重要的，目前为止我们所具体讨论的便是针对此环境。但开发过程中的表现也不容小视。不错的是用 Vue 和 React 开发大多数应用的速度都是足够快的。</p><p style="color: #34495e;">然而，假如你要开发一个对性能要求比较高的数据可视化或者动画的应用时，你需要了解到下面这点：在开发中，Vue 每秒最高处理 10 帧，而 React 每秒最高处理不到 1 帧。</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-adsbygoogle-status="done" data-ad-client="ca-pub-0608155192548477" class="adsbygoogle adsbygoogle-noablate" data-ad-format="auto" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display:inline-table;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><ins id="aswift_5_anchor" style="display:block;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;border:0px;width:613px;height:154px;" frameborder="0" height="154" width="613"></iframe></ins></ins></ins></div><p style="color: #34495e;">Both Vue and React remain fast enough in development for most normal applications. However, when prototyping high frame-rate data visualizations or animations, we’ve seen cases of Vue handling 10 frames per second in development while React dropping to about 1 frame per second.</p><p style="color: #34495e;">这是由于 React 有大量的检查机制，这会让它提供许多有用的警告和错误提示信息。我们同样认为这些是很重要的，但是我们在实现这些检查时，也更加密切地关注了性能方面。</p><h3 id="HTML-amp-CSS" style="color: #2c3e50;">HTML &amp; CSS</h3><p style="color: #34495e;">在 React 中，它们都是 JavaScript 编写的，听起来这十分简单和优雅。然而不幸的事实是，JavaScript 内的 HTML 和 CSS 会产生很多痛点。在 Vue 中我们采用 Web 技术并在其上进行扩展。接下来将通过一些实例向你展示这意味的是什么。</p><h4 id="JSX-vs-Templates" style="color: #2c3e50;">JSX vs Templates</h4><p style="color: #34495e;">在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 Javascript 的一种语法糖。这有一个<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244582684" target="_blank" rel="external">通过React社区审核过的例子</a>：</p><figure class="highlight jsx" style="color: #34495e;"><table><tbody><tr><td class="code"><div class="line">render () {</div><div class="line"><span class="keyword" style="color: #e96900;">let</span> { items } = <span class="keyword" style="color: #e96900;">this</span>.props</div><div class="line"></div><div class="line"><span class="keyword" style="color: #e96900;">let</span> children</div><div class="line"><span class="keyword" style="color: #e96900;">if</span> ( items.length &gt; <span class="number" style="color: #ae81ff;">0</span> ) {</div><div class="line">children = (</div><div class="line"><span class="xml"><span class="tag" style="color: #2973b7;">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line">{items.map( item =&gt;</div><div class="line"><span class="tag" style="color: #2973b7;">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string" style="color: #42b983;">{item.id}</span>&gt;</span>{item.name}<span class="tag" style="color: #2973b7;">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">)}</div><div class="line"><span class="tag" style="color: #2973b7;">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">)</div><div class="line">} <span class="keyword" style="color: #e96900;">else</span> {</div><div class="line">children = <span class="xml"><span class="tag" style="color: #2973b7;">&lt;<span class="name">p</span>&gt;</span>No items found.<span class="tag" style="color: #2973b7;">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword" style="color: #e96900;">return</span> (</div><div class="line"><span class="xml"><span class="tag" style="color: #2973b7;">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string" style="color: #42b983;">‘list-container’</span>&gt;</span></span></div><div class="line">{children}</div><div class="line"><span class="tag" style="color: #2973b7;">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">)</div><div class="line">}</div></td></tr></tbody></table></figure><p style="color: #34495e;">JSX 的渲染功能有下面这些优势：</p><ul style="color: #34495e;"><li>你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。</li><li>工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的（比如，linting、类型检查、编辑器的自动完成）。</li></ul><p style="color: #34495e;">在 Vue 中，由于有时需要用这些功能，我们也提供了<a style="font-weight: 600; color: #42b983;" href="http://cn.vuejs.org/v2/guide/render-function.html">渲染功能</a>&nbsp;并且<a style="font-weight: 600; color: #42b983;" href="http://cn.vuejs.org/v2/guide/render-function.html#JSX">支持了 JSX</a>。然而，对于大多数组件来说，渲染功能是不推荐使用了。</p><p style="color: #34495e;">在这方面，我们提供的是更简单的模板：</p><figure class="highlight html" style="color: #34495e;"><table><tbody><tr><td class="code"><div class="line"><span class="tag" style="color: #2973b7;">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag" style="color: #2973b7;">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string" style="color: #42b983;">“list-container”</span>&gt;</span></div><div class="line"><span class="tag" style="color: #2973b7;">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string" style="color: #42b983;">“items.length”</span>&gt;</span></div><div class="line"><span class="tag" style="color: #2973b7;">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string" style="color: #42b983;">“item in items”</span>&gt;</span></div><div class="line">{{ item.name }}</div><div class="line"><span class="tag" style="color: #2973b7;">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag" style="color: #2973b7;">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag" style="color: #2973b7;">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No items found.<span class="tag" style="color: #2973b7;">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag" style="color: #2973b7;">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag" style="color: #2973b7;">&lt;/<span class="name">template</span>&gt;</span></div></td></tr></tbody></table></figure><p style="color: #34495e;">优点如下：</p><ul style="color: #34495e;"><li>在写模板的过程中，样式风格已定并涉及更少的功能实现。</li><li>模板总是会被声明的。</li><li>模板中任何 HTML 语法都是有效的。</li><li>阅读起来更贴合英语（比如，for each item in items）。</li><li>不需要高级版本的 JavaScript 语法，来增加可读性。</li></ul><p style="color: #34495e;">这样，不仅开发人员更容易编写代码，设计人员和开发人员也可以更容易的分析代码和贡献代码。</p><p style="color: #34495e;">这还没有结束。Vue 拥抱 HTML，而不是用 JavaScript 去重塑它。在模板内，Vue 也允许你用预处理器比如 Pug（原名 Jade）。</p><figure class="highlight plain" style="color: #34495e;"><table><tbody><tr><td class="code"><div class="line">div.list-container</div><div class="line">ul(v-if=”items.length”)</div><div class="line">li(v-for=”item in items”) {{ item.name }}</div><div class="line">p(v-else) No items found.</div></td></tr></tbody></table></figure><h4 id="CSS-的组件作用域" style="color: #2c3e50;">CSS 的组件作用域</h4><p style="color: #34495e;">除非你把组件分布在多个文件上(例如&nbsp;<a style="font-weight: 600; color: #42b983;" href="https://github.com/gajus/react-css-modules" target="_blank" rel="external">CSS Modules</a>)，要不在 React 中作用域内的 CSS 就会产生警告。非常简单的 CSS 还可以工作，但是稍微复杂点的，比如悬停状态、媒体查询、伪类选择符等要么通过沉重的依赖来重做要么就直接不能用。</p><p style="color: #34495e;">而 Vue 可以让你在每个<a style="font-weight: 600; color: #42b983;" href="http://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a>中完全访问 CSS。</p><figure class="highlight html" style="color: #34495e;"><table><tbody><tr><td class="code"><div class="line"><span class="tag" style="color: #2973b7;">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></div><div class="line">@<span class="keyword" style="color: #e96900;">media</span> (min-width: <span class="number" style="color: #ae81ff;">250px</span>) {</div><div class="line"><span class="selector-class">.list-container</span><span class="selector-pseudo">:hover</span> {</div><div class="line"><span class="attribute" style="color: #e96900;">background</span>: orange;</div><div class="line">}</div><div class="line">}</div><div class="line"><span class="tag" style="color: #2973b7;">&lt;/<span class="name">style</span>&gt;</span></div></td></tr></tbody></table></figure><p style="color: #34495e;">这个可选&nbsp;<code style="color: #e96900;">scoped</code>&nbsp;属性会自动添加一个唯一的属性（比如&nbsp;<code style="color: #e96900;">data-v-21e5b78</code>）为组件内 CSS 指定作用域，编译的时候&nbsp;<code style="color: #e96900;">.list-container:hover</code>&nbsp;会被编译成类似<code style="color: #e96900;">.list-container[data-v-21e5b78]:hover</code>。</p><p style="color: #34495e;">最后，就像 HTML 一样，你可以选择自己偏爱的 CSS 预处理器编写 CSS。这可以让你围绕设计为中心展开工作，而不是引入专门的库来增加你应用的体积和复杂度。</p><h3 id="规模" style="color: #2c3e50;">规模</h3><h4 id="向上扩展" style="color: #2c3e50;">向上扩展</h4><p style="color: #34495e;">Vue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神（比如Flux、Redux），而这些状态管理模式甚至<a style="font-weight: 600; color: #42b983;" href="https://github.com/egoist/revue" target="_blank" rel="external">&nbsp;Redux 本身</a>也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式（<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vuex" target="_blank" rel="external">Vuex</a>），更加深入集成 Vue 的状态管理解决方案 Vuex 相信能为你带来更好的开发体验。</p><p style="color: #34495e;">两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-adsbygoogle-status="done" data-ad-client="ca-pub-0608155192548477" class="adsbygoogle adsbygoogle-noablate" data-ad-format="auto" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_6_expand" style="display:inline-table;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><ins id="aswift_6_anchor" style="display:block;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_6" name="aswift_6" style="left:0;position:absolute;top:0;border:0px;width:613px;height:154px;" frameborder="0" height="154" width="613"></iframe></ins></ins></ins></div><p style="color: #34495e;">最后，Vue 提供了<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">Vue-cli 脚手架</a>，能让你非常容易地构建项目，包含了&nbsp;<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">Webpack</a>,<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs-templates/browserify" target="_blank" rel="external">Browserify</a>, 甚至&nbsp;<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs-templates/simple" target="_blank" rel="external">no build system</a>。React 在这方面也提供了<a style="font-weight: 600; color: #42b983;" href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">create-react-app</a>，但是现在还存在一些局限性：</p><ul style="color: #34495e;"><li>它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。</li><li>它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。</li><li>它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。</li></ul><p style="color: #34495e;">而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。如果阅读更多关于<a style="font-weight: 600; color: #42b983;" href="https://github.com/facebookincubator/create-react-app#philosophy" target="_blank" rel="external">不同的设计理念</a>。</p><h4 id="向下扩展" style="color: #2c3e50;">向下扩展</h4><p style="color: #34495e;">React 学习曲线陡峭，在你开始学 React 前，你需要知道 JSX 和 ES2015，因为许多示例用的是这些语法。你需要学习构建系统，虽然你在技术上可以用 Babel 来实时编译代码，但是这并不推荐用于生产环境。</p><p style="color: #34495e;">就像 Vue 向上扩展好比 React 一样，Vue 向下扩展后就类似于 jQuery。你只要把如下标签放到页面就可以运行：</p><p style="color: #34495e;"><code style="color: #e96900;">&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;</code></p><p style="color: #34495e;">然后你就可以编写 Vue 代码并应用到生产中，你只要用 min 版 Vue 文件替换掉就不用担心其他的性能问题。</p><p style="color: #34495e;">由于起步阶段不需学 JSX，ES2015 以及构建系统，所以开发者只需不到一天的时间阅读<a style="font-weight: 600; color: #42b983;" href="http://cn.vuejs.org/v2/guide/">指南</a>就可以建立简单的应用程序。</p><h3 id="本地渲染" style="color: #2c3e50;">本地渲染</h3><p style="color: #34495e;">ReactNative 能使你用相同的组件模型编写有本地渲染能力的 APP（IOS 和 Android）。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue 和&nbsp;<a style="font-weight: 600; color: #42b983;" href="https://alibaba.github.io/weex/" target="_blank" rel="external">Weex</a>&nbsp;会进行官方合作，Weex 是阿里的跨平台用户界面开发框架，Weex 的 JavaScript 框架运行时用的就是 Vue。这意味着在 Weex 的帮助下，你使用 Vue 语法开发的组件不仅仅可以运行在浏览器端，还能被用于开发 IOS 和 Android 上的原生应用。</p><p style="color: #34495e;">在现在，Weex 还在积极发展，成熟度也不能和 ReactNative 相抗衡。但是，Weex 的发展是由世界上最大的电子商务企业的需求在驱动，Vue 团队也会和 Weex 团队积极合作确保为开发者带来良好的开发体验。</p><h3 id="MobX" style="color: #2c3e50;">MobX</h3><p style="color: #34495e;">Mobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。</p><h2 id="Angular-1" style="font-weight: 600; color: #2c3e50;">Angular 1</h2><p style="color: #34495e;">Vue 的一些语法和 Angular 的很相似（例如&nbsp;<code style="color: #e96900;">v-if</code>&nbsp;vs&nbsp;<code style="color: #e96900;">ng-if</code>）。因为 Angular 是 Vue 早期开发的灵感来源。然而，Augular 中存在的许多问题，在 Vue 中已经得到解决。</p><h3 id="复杂性" style="color: #2c3e50;">复杂性</h3><p style="color: #34495e;">在 API 与设计两方面上 Vue.js 都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。</p><h3 id="灵活性和模块化" style="color: #2c3e50;">灵活性和模块化</h3><p style="color: #34495e;">Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1 制定的规则，这让 Vue 能适用于各种项目。我们知道把决定权交给你是非常必要的。<br>这也就是为什么我们提供&nbsp;<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">Webpack template</a>，让你可以用几分钟，去选择是否启用高级特性，比如热模块加载、linting、CSS 提取等等。</p><h3 id="数据绑定" style="color: #2c3e50;">数据绑定</h3><p style="color: #34495e;">Angular 1 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。</p><h3 id="指令与组件" style="color: #2c3e50;">指令与组件</h3><p style="color: #34495e;">在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方。</p><h3 id="性能" style="color: #2c3e50;">性能</h3><p style="color: #34495e;">Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。</p><p style="color: #34495e;">在 Angular 1 中，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。</p><p style="color: #34495e;">Vue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系。</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-adsbygoogle-status="done" data-ad-client="ca-pub-0608155192548477" class="adsbygoogle adsbygoogle-noablate" data-ad-format="auto" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_7_expand" style="display:inline-table;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><ins id="aswift_7_anchor" style="display:block;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_7" name="aswift_7" style="left:0;position:absolute;top:0;border:0px;width:613px;height:154px;" frameborder="0" height="154" width="613"></iframe></ins></ins></ins></div><p style="color: #34495e;">有意思的是，Angular 2 和 Vue 用相似的设计解决了一些 Angular 1 中存在的问题。</p><h2 id="Angular-2" style="font-weight: 600; color: #2c3e50;">Angular 2</h2><p style="color: #34495e;">我们单独将 Augluar 2 作分类，因为它完全是一个全新的框架。例如：它具有优秀的组件系统，并且许多实现已经完全重写，API 也完全改变了。</p><h3 id="TypeScript" style="color: #2c3e50;">TypeScript</h3><p style="color: #34495e;">Angular 1 面向的是较小的应用程序，Angular 2 已转移焦点，面向的是大型企业应用。在这一点上 TypeScript 经常会被引用，它对那些喜欢用 Java 或者 C# 等类型安全的语言的人是非常有用的。</p><p style="color: #34495e;">Vue 也十分适合制作<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/awesome-vue#enterprise-usage" target="_blank" rel="external">企业应用</a>，你也可以通过使用<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vue/tree/dev/types" target="_blank" rel="external">官方类型</a>或<a style="font-weight: 600; color: #42b983;" href="https://github.com/itsFrank/vue-typescript" target="_blank" rel="external">用户贡献的装饰器</a>来支持 TypeScript，这完全是自由可选的。</p><h3 id="大小和性能" style="color: #2c3e50;">大小和性能</h3><p style="color: #34495e;">在性能方面，这两个框架都非常的快。但目前尚没有足够的数据用例来具体展示。如果你一定要量化这些数据，你可以查看<a style="font-weight: 600; color: #42b983;" href="http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html" target="_blank" rel="external">第三方参照</a>，它表明 Vue 2 相比 Angular2 是更快的。</p><p style="color: #34495e;">在大小方面，虽然 Angular 2 使用 tree-shaking 和离线编译技术使代码体积减小了许多。但包含编译器和全部功能的 Vue2(23kb) 相比 Angular 2(50kb) 还是要小的多。但是要注意，用 Angular 2 的 App 的体积缩减是使用了 tree-shaking 移除了那些框架中没有用到的功能，但随着功能引入的不断增多，尺寸会变得越来越大。</p><h3 id="灵活性" style="color: #2c3e50;">灵活性</h3><p style="color: #34495e;">Vue 相比于 Angular 2 则更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何构建。有人可能喜欢用统一的方式来构建，也有很多开发者喜欢这种灵活自由的方式。</p><h3 id="学习曲线" style="color: #2c3e50;">学习曲线</h3><p style="color: #34495e;">开始使用 Vue，你使用的是熟悉的 HTML、符合 ES5 规则的 JavaScript（也就是纯 JavaScript）。有了这些基本的技能，你可以快速地掌握它(<a style="font-weight: 600; color: #42b983;" href="http://cn.vuejs.org/v2/guide/">指南</a>)并投入开发 。</p><p style="color: #34495e;">Angular 2 的学习曲线是非常陡峭的。即使不包括 TypeScript，它的<a style="font-weight: 600; color: #42b983;" href="https://angular.io/docs/js/latest/quickstart.html" target="_blank" rel="external">开始指南</a>中所用的就有 ES2015 标准的 JavaScript，18个 NPM 依赖包，4 个文件和超过 3 千多字的介绍，这一切都是为了完成个 Hello World。而<a style="font-weight: 600; color: #42b983;" href="https://jsfiddle.net/chrisvfritz/50wL7mdz/" target="_blank" rel="external">Vue’s Hello World</a>就非常简单。甚至我们并不用花费一整个页面去介绍它。</p><h2 id="Ember" style="font-weight: 600; color: #2c3e50;">Ember</h2><p style="color: #34495e;">Ember 是一个全能框架。它提供了大量的约定，一旦你熟悉了它们，开发会变得很高效。不过，这也意味着学习曲线较高，而且并不灵活。这意味着在框架和库（加上一系列松散耦合的工具）之间做权衡选择。后者会更自由，但是也要求你做更多架构上的决定。</p><p style="color: #34495e;">也就是说，我们最好比较的是 Vue 内核和 Ember 的<a style="font-weight: 600; color: #42b983;" href="https://guides.emberjs.com/v2.7.0/templates/handlebars-basics/" target="_blank" rel="external">模板</a>与<a style="font-weight: 600; color: #42b983;" href="https://guides.emberjs.com/v2.7.0/object-model/" target="_blank" rel="external">数据模型</a>层：</p><ul style="color: #34495e;"><li>Vue 在普通 JavaScript 对象上建立响应，提供自动化的计算属性。在 Ember 中需要将所有东西放在 Ember 对象内，并且手工为计算属性声明依赖。</li><li>Vue 的模板语法可以用全功能的 JavaScript 表达式，而 Handlebars 的语法和帮助函数相比来说非常受限。</li><li>在性能上，Vue 甩开 Ember 几条街，即使是 Ember 2.0 的最新 Glimmer 引擎。Vue 能够自动批量更新，而 Ember 在关键性能场景时需要手动管理。</li></ul><h2 id="Knockout" style="font-weight: 600; color: #2c3e50;">Knockout</h2><p style="color: #34495e;">Knockout 是 MVVM 领域内的先驱，并且追踪依赖。它的响应系统和 Vue 也很相似。它在<a style="font-weight: 600; color: #42b983;" href="http://knockoutjs.com/documentation/browser-support.html" target="_blank" rel="external">浏览器支持</a>以及其他方面的表现也是让人印象深刻的。它最低能支持到 IE6，而 Vue 最低只能支持到 IE9。</p><p style="color: #34495e;">随着时间的推移，Knockout 的发展已有所放缓，并且略显有点老旧了。比如，它的组件系统缺少完备的生命周期事件方法，尽管这些在现在是非常常见的。以及相比于&nbsp;<a style="font-weight: 600; color: #42b983;" href="http://cn.vuejs.org/v2/guide/components.html#Content-Distribution-with-Slots">Vue</a>&nbsp;调用子组件的接口它的方法显得有点笨重。</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-adsbygoogle-status="done" data-ad-client="ca-pub-0608155192548477" class="adsbygoogle adsbygoogle-noablate" data-ad-format="auto" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_8_expand" style="display:inline-table;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><ins id="aswift_8_anchor" style="display:block;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_8" name="aswift_8" style="left:0;position:absolute;top:0;border:0px;width:613px;height:154px;" frameborder="0" height="154" width="613"></iframe></ins></ins></ins></div><p style="color: #34495e;">如果你有兴趣研究，你还会发现二者在接口设计的理念上是不同的。这可以通过各自创建的<a style="font-weight: 600; color: #42b983;" href="https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89" target="_blank" rel="external">simple Todo List</a>&nbsp;体现出来。或许有点主观，但是很多人认为 Vue 的 API 接口更简单结构更优雅。</p><h2 id="Polymer" style="font-weight: 600; color: #2c3e50;">Polymer</h2><p style="color: #34495e;">Polymer 是另一个由谷歌赞助的项目，事实上也是 Vue 的一个灵感来源。Vue 的组件可以粗略的类比于 Polymer 的自定义元素，并且两者具有相似的开发风格。最大的不同之处在于，Polymer 是基于最新版的 Web Components 标准之上，并且需要重量级的 polyfills 来帮助工作（性能下降），浏览器本身并不支持这些功能。相比而言，Vue 在支持到 IE9 的情况下并不需要依赖 polyfills 来工作，。</p><p style="color: #34495e;">在 Polymer 1.0 版本中，为了弥补性能，团队非常有限的使用数据绑定系统。例如，在 Polymer 中唯一支持的表达式只有布尔值否定和单一的方法调用，它的 computed 方法的实现也并不是很灵活。</p><p style="color: #34495e;">Polymer 自定义的元素是用 HTML 文件来创建的，这会限制使用 JavaScript/CSS（和被现代浏览器普遍支持的语言特性）。相比之下，Vue 的单文件组件允许你非常容易的使用 ES2015 和你想用的 CSS 预编译处理器。</p><p style="color: #34495e;">在部署生产环境时，Polymer 建议使用 HTML Imports 加载所有资源。而这要求服务器和客户端都支持 Http 2.0 协议，并且浏览器实现了此标准。这是否可行就取决于你的目标用户和部署环境了。如果状况不佳，你必须用 Vulcanizer 工具来打包 Polymer 元素。而在这方面，Vue 可以结合异步组件的特性和 Webpack 的代码分割特性来实现懒加载（lazy-loaded）。这同时确保了对旧浏览器的兼容且又能更快加载。</p><p style="color: #34495e;">而 Vue 和 Web Component 标准进行深层次的整合也是完全可行的，比如使用 Custom Elements、Shadow DOM 的样式封装。然而在我们做出严肃的实现承诺之前，我们目前仍在等待相关标准成熟，进而再广泛应用于主流的浏览器中。</p><h2 id="Riot" style="font-weight: 600; color: #2c3e50;">Riot</h2><p style="color: #34495e;">Riot 2.0 提供了一个类似于基于组件的开发模型（在 Riot 中称之为 Tag），它提供了小巧精美的 API。Riot 和 Vue 在设计理念上可能有许多相似处。尽管相比 Riot ，Vue 要显得重一点，Vue 还是有很多显著优势的：</p><ul style="color: #34495e;"><li>根据真实条件来渲染，Riot 根据是否有分支简单显示或隐藏所有内容。</li><li>功能更加强大的路由机制，Riot 的路由功能的 API 是极少的。</li><li>更多成熟工具的支持。Vue 提供官方支持<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vue-loader" target="_blank" rel="external">Webpack</a>、<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vueify" target="_blank" rel="external">Browserify</a>和<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/systemjs-plugin-vue" target="_blank" rel="external">SystemJS</a>，而 Riot 是依靠社区来建立集成系统。</li><li><a style="font-weight: 600; color: #42b983;" href="http://cn.vuejs.org/v2/guide/transitions.html">过渡效果系统</a>。Riot 现在还没有提供。</li><li>更好的性能。Riot&nbsp;<a style="font-weight: 600; color: #42b983;" href="https://github.com/vuejs/vuejs.org/issues/346" target="_blank" rel="external">尽管声称</a>其使用了虚拟 DOM，但实际上用的还是脏检查机制，因此和 Angular 1 患有相同的性能问题。</li></ul>			    ' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
        tag:"前端开发",
        images:"https://cloud.githubusercontent.com/assets/10385585/15822781/7122b71c-2c2a-11e6-946a-bb7912759395.png",
        title:'React同构直出优化总结 ',
        describe:'React 的实践从去年在 PC QQ家校群开始，由于 PC 上的网络及环境都相当好，所以在使用时可谓一帆风顺，偶尔遇到点小磕绊，也能够快速地填补磨平。而最近一段时间，我们将手Q的家校群重构成 React，除了原有框架上存在明显问题的原因外，选择React也是因为它确实有足够的吸...',
        author:"古歌",
        time:"2016-08-23",
        flow:734,
        comments:[],
        enjoy:4,
        id:"7123.html",
        content:'<p style="color: #444444;">React 的实践从去年在 PC QQ家校群开始，由于 PC 上的网络及环境都相当好，所以在使用时可谓一帆风顺，偶尔遇到点小磕绊，也能够快速地填补磨平。而最近一段时间，我们将手Q的家校群重构成 React，除了原有框架上存在明显问题的原因外，选择React也是因为它确实有足够的吸引力以及优势，加之在PC家校群上的实践经验，斟酌下便开始了，到现在已有页面在线上正常跑起。</p><p style="color: #444444;"></p><p style="color: #444444;"></p><p style="color: #444444;">由于移动端上的网络及环境迥异，性能偏差。所以在移动端上用 React 时，遇到了不少的坑点，也花了一些力气在上面。关于在移动端上的优化，可看我们团队的另一篇文章的&nbsp;<a style="color: #1982d1;" href="http://www.alloyteam.com/2016/05/react-mobile-web-optimization/">React移动端web极致优化</a></p><p style="color: #444444;"><strong>一提到优化，不得不提直出</strong><br>关于这块可以查看&nbsp;<a style="color: #1982d1;" href="https://github.com/joeyguo/blog/issues/8" rel="nofollow">Node直出理论与实践总结</a>，这篇文章较详细的分析直出的概念及一步步优化，也结合了 手Q家校群使用快速的<strong>数据直出</strong>方式来优化性能的总结与性能数据分析</p><p style="color: #444444;"><strong>一提到 React，不得不提同构</strong><br>同构基于服务端渲染，却不止是服务端渲染。</p><p style="color: #444444;"></p><h1>服务端渲染到同构的这一路</h1><h3>后台包办</h3><p style="color: #444444;">服务端渲染的方案早在后台程序前后端包办的时代上就有了，那时候使用JSP、PHP等动态语言将数据与页面模版整合后输出给浏览器，一步到位</p><p style="color: #444444;"><a style="color: #1982d1;" href="https://cloud.githubusercontent.com/assets/10385585/15822781/7122b71c-2c2a-11e6-946a-bb7912759395.png" target="_blank" rel="prettyPhoto[1]"><img data-tag="bdshare" class="ls_slideshow_imgs" title="" src="https://cloud.githubusercontent.com/assets/10385585/15822781/7122b71c-2c2a-11e6-946a-bb7912759395.png" alt="22"></a></p><p style="color: #444444;">这个时候，前端开发跟后端揉为一体，项目小的时候，前后端的开发和调试还真可以称为一步到位。但当项目庞大起来的时候，无论是修改某个样式要起一个庞大服务的尴尬，还是前后端糅合的地带变得越来越难以维护，都很难过。</p><h3>前后分离</h3><p style="color: #444444;">前后端分离后，服务端渲染的模式就开始被淡化了。这时候的服务端渲染比较尴尬，由于前后端的编码语言不同，连页面模板都不能复用，只能让在前后端开发完成后，再将前端代码改为给后端使用的页面模板，增大了工作量。最终也还是跟后台包办殊途同归。</p><h3>语言变通</h3><p style="color: #444444;">Node 驾着祥云腾空而来，谷歌 V8 引擎给力支持，众前端拿着看家本领(JavaScript)开始涉足服务端，于是服务端渲染上又一步进阶</p><p style="color: #444444;"><a style="color: #1982d1;" href="https://cloud.githubusercontent.com/assets/10385585/15822809/9658984e-2c2a-11e6-980e-bca200655749.png" target="_blank" rel="prettyPhoto[1]"><img data-tag="bdshare" class="ls_slideshow_imgs" title="" src="https://cloud.githubusercontent.com/assets/10385585/15822809/9658984e-2c2a-11e6-980e-bca200655749.png" alt="33"></a></p><p style="color: #444444;">由于前后端时候的相同的语言，所以前后端在代码的共用上达到了新的高度，页面模版、node modules 都可以做成前后通用。同构的雏形，只是共用的代码还是有局限。</p><h3>前后同构</h3><p style="color: #444444;">有了Node 后，前端便有了更多的想象空间。前端框架开始考虑兼容服务端渲染，提供更方便的 API，前后端共用一套代码的方案，让服务端渲染越来越便捷。当然，不只是 React 做了这件事，但 React 将这种思想推向高潮，同构的概念也开始广为人传。</p><p style="color: #444444;"><a style="color: #1982d1;" href="https://cloud.githubusercontent.com/assets/10385585/15822951/1f550bc8-2c2b-11e6-9551-d143d5cc1992.png" target="_blank" rel="prettyPhoto[1]"><img data-tag="bdshare" class="ls_slideshow_imgs" title="" src="https://cloud.githubusercontent.com/assets/10385585/15822951/1f550bc8-2c2b-11e6-9551-d143d5cc1992.png" alt="55"></a></p><p style="color: #444444;">关于 React 网上已有大多教程，可以查看阮老师的<a style="color: #1982d1;" href="https://github.com/ruanyf/react-demos" rel="nofollow">react-demos</a>。关于 React 上的数据流管理方案，现在最为火热的 Redux 应该是首选，具体可以查看另一篇文章&nbsp;<a style="color: #1982d1;" href="https://github.com/joeyguo/blog/issues/9" rel="nofollow">React 数据流管理架构之Redux</a>，此篇就不再赘述，下面讲讲 React 同构的理论与在手Q家校群上的具体实践总结。</p><p style="color: #444444;"></p><h1>React 同构</h1><h2 style="font-weight: bold;">React 虚拟 Dom</h2><p style="color: #444444;">React 的虚拟 Dom 以对象树的形式保存在内存中，并存在前后端两种展露原型的形式</p><p style="color: #444444;"><a style="color: #1982d1;" href="https://cloud.githubusercontent.com/assets/10385585/15844706/fc3854be-2c9e-11e6-8de9-2ba5f9e5a9fb.png" target="_blank" rel="prettyPhoto[1]"><img data-tag="bdshare" class="ls_slideshow_imgs" title="" src="https://cloud.githubusercontent.com/assets/10385585/15844706/fc3854be-2c9e-11e6-8de9-2ba5f9e5a9fb.png" alt="rendertype"></a></p><ol><li>客户端上，虚拟 Dom 通过 ReactDOM 的 Render 方法渲染到页面中</li><li>服务端上，React 提供的另外两个方法：ReactDOMServer.renderToString 和 ReactDOMServer.renderToStaticMarkup 可将其渲染为 HTML 字符串。</li><li></li></ol><h2 style="font-weight: bold;">React 同构的关键要素</h2><p style="color: #444444;">完善的 Compponent 属性及生命周期与客户端的 render 时机是 React 同构的关键。</p><p style="color: #444444;"><strong>DOM 的一致性</strong><br>在前后端渲染相同的 Compponent，将输出一致的 Dom 结构。</p><p style="color: #444444;"><strong>不同的生命周期</strong><br>在服务端上 Component 生命周期只会到 componentWillMount，客户端则是完整的。</p><p style="color: #444444;"><strong>客户端 render 时机</strong><br>同构时，服务端结合数据将 Component 渲染成完整的 HTML 字符串并将数据状态返回给客户端，客户端会判断是否可以直接使用或需要重新挂载。</p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-adsbygoogle-status="done" data-ad-client="ca-pub-0608155192548477" class="adsbygoogle adsbygoogle-noablate" data-ad-format="auto" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_4_expand" style="display:inline-table;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><ins id="aswift_4_anchor" style="display:block;border:none;height:154px;margin:0;padding:0;position:relative;visibility:visible;width:613px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_4" name="aswift_4" style="left:0;position:absolute;top:0;border:0px;width:613px;height:154px;" frameborder="0" height="154" width="613"></iframe></ins></ins></ins></div><p style="color: #444444;">以上便是 React 在同构/服务端渲染的提供的基础条件。在实际项目应用中，还需要考虑其他边角问题，例如服务器端没有 window 对象，需要做不同处理等。下面将通过在手Q家校群上的具体实践，分享一些同构的 Tips 及优化成果</p><p style="color: #444444;"></p><h1>以手Q家校群 React 同构实践为例</h1><p style="color: #444444;">手Q家校群使用 React + Redux + Webpack 的架构</p><p style="color: #444444;"></p><h2 style="font-weight: bold;">同构实践 Tips</h2><h3>1. renderToString 和 renderToStaticMarkup</h3><p style="color: #444444;">ReactDOMServer 提供 renderToString 和 renderToStaticMarkup 的方法，大多数情况使用<strong>renderToString</strong>，这样会为组件增加 checksum</p><p style="color: #444444;"><a style="color: #1982d1;" href="https://cloud.githubusercontent.com/assets/10385585/15844528/a8adcc9e-2c9d-11e6-94b9-3bb273f48e53.png" target="_blank" rel="prettyPhoto[1]"><img data-tag="bdshare" class="ls_slideshow_imgs" title="" src="https://cloud.githubusercontent.com/assets/10385585/15844528/a8adcc9e-2c9d-11e6-94b9-3bb273f48e53.png" alt="checknum"></a></p><p style="color: #444444;">React 在客户端通过 checksum 判断是否需要重新render<br><strong>相同</strong>则不重新render，省略创建DOM和挂载DOM的过程，接着触发 componentDidMount 等事件来处理服务端上的未尽事宜(事件绑定等)，从而加快了交互时间；<strong>不同</strong>时，组件将客户端上被重新挂载 render。</p><p style="color: #444444;"><strong>renderToStaticMarkup</strong>&nbsp;则不会生成与 react 相关的data-*，也不存在 checksum，输出的 html 如下</p><p style="color: #444444;"><a style="color: #1982d1;" href="https://cloud.githubusercontent.com/assets/10385585/15845314/7085895e-2ca4-11e6-97e7-772d817a892c.png" target="_blank" rel="prettyPhoto[1]"><img data-tag="bdshare" class="ls_slideshow_imgs" title="" src="https://cloud.githubusercontent.com/assets/10385585/15845314/7085895e-2ca4-11e6-97e7-772d817a892c.png" alt="3333"></a></p><p style="color: #444444;">在客户端时组件会被重新挂载，客户端重新挂载不生成 checknum( 也没这个必要 )，所以该方法只当服务端上所渲染的组件在客户端不需要时才使用</p><p style="color: #444444;"><a style="color: #1982d1;" href="https://cloud.githubusercontent.com/assets/10385585/15845159/cfc6d0c8-2ca2-11e6-9cbc-45b8318b33dc.png" target="_blank" rel="prettyPhoto[1]"><img data-tag="bdshare" class="ls_slideshow_imgs" title="" src="https://cloud.githubusercontent.com/assets/10385585/15845159/cfc6d0c8-2ca2-11e6-9cbc-45b8318b33dc.png" alt="checknum"></a></p><p style="color: #444444;"></p><h3>2. 服务端上的数据状态与同步给客户端</h3><p style="color: #444444;">服务端上的产生的数据需要随着页面一同返回，客户端使用该数据去 render，从而保持状态一致。服务端上使用 renderToString 而在客户端上依然重新挂载组件的情况大多是因为在返回 HTML 的时候没有将服务端上的数据一同返回，或者是返回的数据格式不对导致，开发时可以留意 chrome 上的提示如</p><p style="color: #444444;"><a style="color: #1982d1;" href="https://cloud.githubusercontent.com/assets/10385585/15846321/a270a976-2cae-11e6-9044-ec7bdac63e9f.png" target="_blank" rel="prettyPhoto[1]"><img data-tag="bdshare" class="ls_slideshow_imgs" title="" src="https://cloud.githubusercontent.com/assets/10385585/15846321/a270a976-2cae-11e6-9044-ec7bdac63e9f.png" alt="noti"></a></p><p style="color: #444444;"></p><h3>3. 服务端需提前拉取数据，客户端则在 componentDidMount 调用</h3><p style="color: #444444;"><strong>平台上的差异</strong>，服务端渲染只会执行到 compnentWillMount 上，所以为了达到同构的目的，可以把拉取数据的逻辑写到 React Class 的静态方法上，一方面服务端上可以通过直接操作静态方法来提前拉取数据再根据数据生成 HTML，另一方面客户端可以在 componentDidMount 时去调用该静态方法拉取数据</p><p style="color: #444444;"></p><h3>4. 保持数据的确定性</h3><p style="color: #444444;">这里指影响组件 render 结果的数据，举个例子，下面的组件由于在服务端与客户端渲染上会因为组件上产生不同随机数的原因而导致客户端将重新渲染。</p><p style="color: #444444;"></p><div id="crayon-580cb91ce03f5372784481" class="crayon-syntax crayon-theme-sublime-text crayon-font-courier-new crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><div class="crayon-plain-wrap"></div><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " style="color: #868686 !important;" data-settings="show"><div class="crayon-nums-content"><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce03f5372784481-1">1</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce03f5372784481-2">2</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce03f5372784481-3">3</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce03f5372784481-4">4</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce03f5372784481-5">5</div></div></td><td class="crayon-code"><div class="crayon-pre" style="color: #f8f8f2 !important;"><div id="crayon-580cb91ce03f5372784481-1" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-t" style="font-weight: inherit !important; color: #a6e22d !important;">Class</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">Wrapper</span><span class="crayon-r" style="font-weight: inherit !important; color: #66d9ef !important;">extends</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">Component</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce03f5372784481-2" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">render</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce03f5372784481-3" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st" style="font-weight: inherit !important; color: #66d9ef !important;">return</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-o" style="font-weight: inherit !important;">&lt;</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">h1</span><span class="crayon-o" style="font-weight: inherit !important;">&gt;</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span><span class="crayon-v" style="font-weight: inherit !important;">Math</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">random</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">}</span><span class="crayon-o" style="font-weight: inherit !important;">&lt;</span><span class="crayon-o" style="font-weight: inherit !important;">/</span><span class="crayon-v" style="font-weight: inherit !important;">h1</span><span class="crayon-o" style="font-weight: inherit !important;">&gt;</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">;</span></div><div id="crayon-580cb91ce03f5372784481-4" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;</span><span class="crayon-sy" style="font-weight: inherit !important;">}</span></div><div id="crayon-580cb91ce03f5372784481-5" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-sy" style="font-weight: inherit !important;">}</span><span class="crayon-sy" style="font-weight: inherit !important;">;</span></div></div></td></tr></tbody></table></div></div><p style="color: #444444;"></p><p style="color: #444444;">可以将 Math.random() 封装至Component 的 props 中，在服务端上生成随机数并传入到这个component中，从而保证随机数在客户端和服务端一致。如</p><p style="color: #444444;"></p><div id="crayon-580cb91ce0400575215270" class="crayon-syntax crayon-theme-sublime-text crayon-font-courier-new crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><div class="crayon-plain-wrap"></div><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " style="color: #868686 !important;" data-settings="show"><div class="crayon-nums-content"><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0400575215270-1">1</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0400575215270-2">2</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0400575215270-3">3</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0400575215270-4">4</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0400575215270-5">5</div></div></td><td class="crayon-code"><div class="crayon-pre" style="color: #f8f8f2 !important;"><div id="crayon-580cb91ce0400575215270-1" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-t" style="font-weight: inherit !important; color: #a6e22d !important;">Class</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">Wrapper</span><span class="crayon-r" style="font-weight: inherit !important; color: #66d9ef !important;">extends</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">Component</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce0400575215270-2" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">render</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce0400575215270-3" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-st" style="font-weight: inherit !important; color: #66d9ef !important;">return</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-o" style="font-weight: inherit !important;">&lt;</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">h1</span><span class="crayon-o" style="font-weight: inherit !important;">&gt;</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span><span class="crayon-r" style="font-weight: inherit !important; color: #66d9ef !important;">this</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-v" style="font-weight: inherit !important;">props</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-v" style="font-weight: inherit !important;">randomNum</span><span class="crayon-sy" style="font-weight: inherit !important;">}</span><span class="crayon-o" style="font-weight: inherit !important;">&lt;</span><span class="crayon-o" style="font-weight: inherit !important;">/</span><span class="crayon-v" style="font-weight: inherit !important;">h1</span><span class="crayon-o" style="font-weight: inherit !important;">&gt;</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">;</span></div><div id="crayon-580cb91ce0400575215270-4" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;</span><span class="crayon-sy" style="font-weight: inherit !important;">}</span></div><div id="crayon-580cb91ce0400575215270-5" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-sy" style="font-weight: inherit !important;">}</span><span class="crayon-sy" style="font-weight: inherit !important;">;</span></div></div></td></tr></tbody></table></div></div><p style="color: #444444;"></p><p style="color: #444444;">服务端上传入randomNum</p><p style="color: #444444;"></p><div id="crayon-580cb91ce0405183312605" class="crayon-syntax crayon-theme-sublime-text crayon-font-courier-new crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><div class="crayon-plain-wrap"></div><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " style="color: #868686 !important;" data-settings="show"><div class="crayon-nums-content"><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0405183312605-1">1</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0405183312605-2">2</div></div></td><td class="crayon-code"><div class="crayon-pre" style="color: #f8f8f2 !important;"><div id="crayon-580cb91ce0405183312605-1" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">let </span><span class="crayon-v" style="font-weight: inherit !important;">randomNum</span><span class="crayon-o" style="font-weight: inherit !important;">=</span><span class="crayon-v" style="font-weight: inherit !important;">Math</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">random</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span></div><div id="crayon-580cb91ce0405183312605-2" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-t" style="font-weight: inherit !important; color: #a6e22d !important;">var</span><span class="crayon-v" style="font-weight: inherit !important;">html</span><span class="crayon-o" style="font-weight: inherit !important;">=</span><span class="crayon-v" style="font-weight: inherit !important;">ReacDOMServer</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">renderToString</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-o" style="font-weight: inherit !important;">&lt;</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">Wrapper </span><span class="crayon-v" style="font-weight: inherit !important;">randomNum</span><span class="crayon-o" style="font-weight: inherit !important;">=</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span><span class="crayon-v" style="font-weight: inherit !important;">randomNum</span><span class="crayon-sy" style="font-weight: inherit !important;">}</span><span class="crayon-o" style="font-weight: inherit !important;">/</span><span class="crayon-o" style="font-weight: inherit !important;">&gt;</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">;</span></div></div></td></tr></tbody></table></div></div><p style="color: #444444;"></p><p style="color: #444444;"></p><h3>5. 平台区分</h3><p style="color: #444444;">当前后端共用一套代码的时候，像前端特有的 Window 对象，Ajax 请求 在后端是无法使用上的，后端需要去掉这些前端特有的对象逻辑或使用对应的后端方案，如后端可以使用 http.request 替代 Ajax 请求，所以需要进行平台区分，主要有以下几种方式</p><p style="color: #444444;">1.代码使用前后端通用的模块，如 isomorphic-fetch<br>2.前后端通过webpack 配置 resolve.alias 对应不同的文件，如<br>客户端使用 /browser/request.js 来做 ajax 请求</p><p style="color: #444444;"></p><div id="crayon-580cb91ce040e506204563" class="crayon-syntax crayon-theme-sublime-text crayon-font-courier-new crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><div class="crayon-plain-wrap"></div><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " style="color: #868686 !important;" data-settings="show"><div class="crayon-nums-content"><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce040e506204563-1">1</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce040e506204563-2">2</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce040e506204563-3">3</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce040e506204563-4">4</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce040e506204563-5">5</div></div></td><td class="crayon-code"><div class="crayon-pre" style="color: #f8f8f2 !important;"><div id="crayon-580cb91ce040e506204563-1" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-v" style="font-weight: inherit !important;">resolve</span><span class="crayon-o" style="font-weight: inherit !important;">:</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce040e506204563-2" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v" style="font-weight: inherit !important;">alias</span><span class="crayon-o" style="font-weight: inherit !important;">:</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce040e506204563-3" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-s" style="font-weight: inherit !important; color: #e6db5d !important;">‘request’</span><span class="crayon-o" style="font-weight: inherit !important;">:</span><span class="crayon-v" style="font-weight: inherit !important;">path</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">join</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-v" style="font-weight: inherit !important;">pathConfig</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-v" style="font-weight: inherit !important;">src</span><span class="crayon-sy" style="font-weight: inherit !important;">,</span><span class="crayon-s" style="font-weight: inherit !important; color: #e6db5d !important;">‘/browser/request’</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">,</span></div><div id="crayon-580cb91ce040e506204563-4" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy" style="font-weight: inherit !important;">}</span></div><div id="crayon-580cb91ce040e506204563-5" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-sy" style="font-weight: inherit !important;">}</span></div></div></td></tr></tbody></table></div></div><p style="color: #444444;"></p><p style="color: #444444;">服务端 webpack 上使用 /server/request.js 以 http.request 替代 ajax 请求</p><p style="color: #444444;"></p><div id="crayon-580cb91ce0413951300878" class="crayon-syntax crayon-theme-sublime-text crayon-font-courier-new crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><div class="crayon-plain-wrap"></div><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " style="color: #868686 !important;" data-settings="show"><div class="crayon-nums-content"><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0413951300878-1">1</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0413951300878-2">2</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0413951300878-3">3</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0413951300878-4">4</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0413951300878-5">5</div></div></td><td class="crayon-code"><div class="crayon-pre" style="color: #f8f8f2 !important;"><div id="crayon-580cb91ce0413951300878-1" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-v" style="font-weight: inherit !important;">resolve</span><span class="crayon-o" style="font-weight: inherit !important;">:</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce0413951300878-2" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-v" style="font-weight: inherit !important;">alias</span><span class="crayon-o" style="font-weight: inherit !important;">:</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce0413951300878-3" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-s" style="font-weight: inherit !important; color: #e6db5d !important;">‘request’</span><span class="crayon-o" style="font-weight: inherit !important;">:</span><span class="crayon-v" style="font-weight: inherit !important;">path</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">join</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-v" style="font-weight: inherit !important;">pathConfig</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-v" style="font-weight: inherit !important;">src</span><span class="crayon-sy" style="font-weight: inherit !important;">,</span><span class="crayon-s" style="font-weight: inherit !important; color: #e6db5d !important;">‘/server/request’</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">,</span></div><div id="crayon-580cb91ce0413951300878-4" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-sy" style="font-weight: inherit !important;">}</span></div><div id="crayon-580cb91ce0413951300878-5" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-sy" style="font-weight: inherit !important;">}</span></div></div></td></tr></tbody></table></div></div><p style="color: #444444;"></p><p style="color: #444444;">3.使用 webpack.DefinePlugin 在构建时添加一个平台区分的值，这种方式的在 webpack UglifyJsPlugin 编译后，非当前平台( 不可达代码 )的代码将会被去掉，不会增加文件大小。如<br>在服务端的 webpack 加上下面配置</p><p style="color: #444444;"></p><div id="crayon-580cb91ce0417642521804" class="crayon-syntax crayon-theme-sublime-text crayon-font-courier-new crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><div class="crayon-plain-wrap"></div><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " style="color: #868686 !important;" data-settings="show"><div class="crayon-nums-content"><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0417642521804-1">1</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0417642521804-2">2</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce0417642521804-3">3</div></div></td><td class="crayon-code"><div class="crayon-pre" style="color: #f8f8f2 !important;"><div id="crayon-580cb91ce0417642521804-1" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-r" style="font-weight: inherit !important; color: #66d9ef !important;">new</span><span class="crayon-v" style="font-weight: inherit !important;">webpack</span><span class="crayon-sy" style="font-weight: inherit !important;">.</span><span class="crayon-e" style="font-weight: inherit !important; color: #f92650 !important;">DefinePlugin</span><span class="crayon-sy" style="font-weight: inherit !important;">(</span><span class="crayon-sy" style="font-weight: inherit !important;">{</span></div><div id="crayon-580cb91ce0417642521804-2" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-h" style="font-weight: inherit !important; color: #006fe0 !important;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="crayon-s" style="font-weight: inherit !important; color: #e6db5d !important;">“__ISOMORPHIC__”</span><span class="crayon-o" style="font-weight: inherit !important;">:</span><span class="crayon-t" style="font-weight: inherit !important; color: #a6e22d !important;">true</span></div><div id="crayon-580cb91ce0417642521804-3" class="crayon-line" style="font-weight: inherit !important;"><span class="crayon-sy" style="font-weight: inherit !important;">}</span><span class="crayon-sy" style="font-weight: inherit !important;">)</span><span class="crayon-sy" style="font-weight: inherit !important;">,</span></div></div></td></tr></tbody></table></div></div><p style="color: #444444;"></p><p style="color: #444444;">在JS逻辑上做判断</p><p style="color: #444444;"></p><div id="crayon-580cb91ce041b979837116" class="crayon-syntax crayon-theme-sublime-text crayon-font-courier-new crayon-os-pc print-yes notranslate" data-settings=" minimize scroll-mouseover"><div class="crayon-plain-wrap"></div><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " style="color: #868686 !important;" data-settings="show"><div class="crayon-nums-content"><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce041b979837116-1">1</div><div class="crayon-num" style="font-weight: inherit !important;" data-line="crayon-580cb91ce041b979837116-2">2</div><div class="crayon-num" style="font-weight' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
         
        tag:"前端开发",
        images:"http://www.yyyweb.com/wp-content/themes/dream/images/thumbnail.png",
        title:'React Canvas：高性能渲染 React 组件 ',
        describe:'React Canvas 提供了使用 Canvas 渲染移动 Web App 界面的能力，替代传统的 DOM 渲染，具有更接近 Native App 的使用体验。React Canvas 提供了一组标准的 React 组件，由基于的渲染元素抽象而成。',
        author:"古歌",
        time:"2015-07-12",
        flow:5251,
        comments:[],
        enjoy:6,
        id:"7124.html",
        content:'<p>React Canvas 提供了使用 <a href="http://www.cnblogs.com/lhb25/category/146076.html" target="_blank"><strong>Canvas</strong></a> 渲染移动 Web App 界面的能力，替代传统的 <a href="http://www.cnblogs.com/lhb25/category/146076.html" target="_blank"><strong>DOM</strong></a> 渲染，具有更接近 Native App 的使用体验。React Canvas 提供了一组标准的 React 组件，由基于的渲染元素抽象而成。<span id="more-3692"></span></p><p style="text-align: center;"></p><p style="text-align: center;"><a href="https://github.com/Flipboard/react-canvas" target="_blank"><img data-tag="bdshare" src="http://images.cnitblog.com/blog2015/36987/201503/081221266952375.jpg" alt="React Canvas：高性能渲染 React 组"></a></p><p style="text-align: center;"></p><p style="text-align: center;"><a href="https://github.com/Flipboard/react-canvas" target="_blank">GitHub</a>&nbsp; &nbsp; &nbsp;&nbsp;<a href="http://www.yyyweb.com/ctools/download.php?target=https%3A%2F%2Fgithub.com%2FFlipboard%2Freact-canvas%2Farchive%2Fmaster.zip" target="_blank">源码下载</a></p><p>示例代码：</p><div><pre>var React = require("react");  var ReactCanvas = require("react-canvas");    var Surface = ReactCanvas.Surface;  var Image = ReactCanvas.Image;  var Text = ReactCanvas.Text;    var MyComponent = React.createClass({      render: function () {      var surfaceWidth = window.innerWidth;      var surfaceHeight = window.innerHeight;      var imageStyle = this.getImageStyle();      var textStyle = this.getTextStyle();        return (        &lt;Surface width={surfaceWidth} height={surfaceHeight} left={0} top={0}&gt;          &lt;Image style={imageStyle} src=""..." /&gt;          &lt;Text style={textStyle}&gt;            Here is some text below an image.          &lt;/Text&gt;        &lt;/Surface&gt;      );    },      getImageHeight: function () {      return Math.round(window.innerHeight / 2);    },      getImageStyle: function () {      return {        top: 0,        left: 0,        width: window.innerWidth,        height: this.getImageHeight()      };    },      getTextStyle: function () {      return {        top: this.getImageHeight() + 10,        left: 0,        width: window.innerWidth,        height: 20,        lineHeight: 20,        fontSize: 12      };    }    });</pre></div>			      ' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
         
        tag:"前端开发",
        images:"http://www.yyyweb.com/wp-content/themes/dream/images/thumbnail.png",
        title:'Reapp – 下一代的 Hybrid App 开发框架 ',
        describe:'Reapp 与 React Native 有着惊人的相似之处，二者都使用 React 来创建应用程序用户界面的框架。然而，在底层机制上这两个框架之间却具有明显的哲学差异。React Native 将 React 组件绑定到原生 UI 控件中，构建与设备操作系统匹配的界面。而 Re...',
        author:"古歌",
        time:"2015-06-11",
        flow:5292,
        comments:[],
        enjoy:4,
        id:"7125.html",
        content:'<p>Reapp 与 React Native 有着惊人的相似之处，二者都使用 React 来创建应用程序用户界面的框架。然而，在底层机制上这两个框架之间却具有明显的哲学差异。React Native 将 React 组件绑定到原生 UI 控件中，构建与设备操作系统匹配的界面。而 Reapp 却是将 React 组件绑定到一个跨平台的 UI-Kit 来创建混搭应用。<span id="more-3693"></span></p><p><a href="http://www.yyyweb.com/ctools/demo.php?t=http%3A%2F%2Freapp.io%2F&amp;h=7000&amp;c=&amp;n=reapp" target="_blank" rel="nofollow"><img data-tag="bdshare" class="aligncenter" src="http://images.cnitblog.com/blog2015/36987/201503/081329363998002.jpg" alt="Reapp - 下一代的 Hybrid App 开发框架"></a></p><p style="text-align: center;"><a class="demo" href="http://www.yyyweb.com/ctools/demo.php?t=http%3A%2F%2Freapp.io%2F&amp;h=7000&amp;c=&amp;n=reapp" target="_blank">官方网站</a>&nbsp; &nbsp; &nbsp;&nbsp;<a class="download" href="https://github.com/reapp/reapp" target="_blank">GitHub</a></p>			   ' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
         
        tag:"前端开发",
        images:"http://www.yyyweb.com/wp-content/themes/dream/images/thumbnail.png",
        title:' Material UI – Material Design CSS 框架',
        describe:'Material Design 是谷歌推出的全新的设计理念，采用大胆的色彩、流畅的动画播放，以及卡片式的简洁设计。Material Design 风格的设计拥有干净的排版和简单的布局，容易理解，内容才是焦点。',
        author:"古歌",
        time:"2015-05-05",
        flow:4728,
        comments:[],
        enjoy:8,
        id:"7126.html",
        content:'<p>Material Design 是谷歌推出的全新的设计理念，采用大胆的色彩、流畅的动画播放，以及卡片式的简洁设计。Material Design 风格的设计拥有干净的排版和简单的布局，容易理解，内容才是焦点。<span id="more-3334"></span></p><p>Material UI&nbsp;是一个 CSS 框架和一组实现谷歌 Material Design&nbsp;设计规范的 React 组件。可以作为 NPM 安装包，使用 browserify 和 reactify 的依赖管理和 JSX 转换。</p><p>&nbsp;</p><p><a href="http://www.yyyweb.com/demo/inner-show/material-ui.html" target="_blank"><img data-tag="bdshare" style="display: block; margin-left: auto; margin-right: auto;" src="http://images.cnitblog.com/blog/36987/201411/292229502461154.jpg" alt="Material UI – Material Design CSS 框架"></a></p><p style="text-align: center;"><a class="demo" href="http://material-ui.com/#/components/buttons" target="_blank">在线演示</a>&nbsp; &nbsp; &nbsp;&nbsp;<a class="download" href="http://www.yyyweb.com/demo/inner-show/material-ui.html" target="_blank">插件下载</a></p>			        		' 
    }, 
    {
        type:"React",
        type_url:"/category/technique/React", 
         
        tag:"前端开发",
        images:"http://mmbiz.qpic.cn/mmbiz/fVKPLN9XPQKcDYY3EscTpbqPJ8YzrDvWMtuOsJSPQ2fRKBP3Cs0RAfEp348pOqXueYqyduVWAfibnFrcwVqauqw/0?tp=webp&wxfrom=5",
        title:' Canvas UI – 高性能的移动 UI 框架',
        describe:' WebView 里无法获得的能力虽然是「体验增强」与「端基本能力」，但现都基本上有成熟解决方法。但后期的 UI 和 Layout 的性能反而是目前 Web 技术欠缺的。所以，无论是 Titanium 与 React Native 都是解决性能作为探索的出发点。 性能...',
        author:"古歌",
        time:" 2015-03-02",
        flow:4981,
        comments:[],
        enjoy:8,
        id:"7127.html",
        content:'<div id="media" class="rich_media_thumb_wrp" style="color: #000000;"><img data-tag="bdshare" id="js_cover" class="rich_media_thumb aligncenter" src="http://mmbiz.qpic.cn/mmbiz/fVKPLN9XPQKcDYY3EscTpbqPJ8YzrDvWMtuOsJSPQ2fRKBP3Cs0RAfEp348pOqXueYqyduVWAfibnFrcwVqauqw/0?tp=webp&amp;wxfrom=5" alt=""></div><div class="rich_media_thumb_wrp" style="color: #000000;"></div><p>&nbsp;</p><p>WebView 里无法获得的能力虽然是「体验增强」与「端基本能力」，但现都基本上有成熟解决方法。但后期的 UI 和 Layout 的性能反而是目前 Web 技术欠缺的。所以，无论是 Titanium 与 React Native 都是解决性能作为探索的出发点。</p><div id="js_content" class="rich_media_content" style="color: #3e3e3e;"><p><strong>性能慢与快的分水岭.</strong></p><p><img data-tag="bdshare" id="c1424010191586" class="content_image aligncenter" src="http://mmbiz.qpic.cn/mmbiz/fVKPLN9XPQKF0S04Z1CBTke2yq8FDytQ6HfpO4Q3VebaZqhqsNlQ1eRd549fhY98P48O7Z9ljTsJEuKgjAxTCw/0?tp=webp&amp;wxfrom=5" alt="" data-src="http://mmbiz.qpic.cn/mmbiz/fVKPLN9XPQKF0S04Z1CBTke2yq8FDytQ6HfpO4Q3VebaZqhqsNlQ1eRd549fhY98P48O7Z9ljTsJEuKgjAxTCw/0" data-rawwidth="740" data-rawheight="230" data-type="png" data-ratio="0.3090551181102362" data-w="508"></p><p>慢与快的标准，是按照每秒大于等于 60 FPS（60 帧每秒） 的理论，而为什么是 60 FPS，这不多描述。</p><p>按此理论，那么「每帧」里所有的操作都必须在 16ms 完成。</p><p><strong>WebView 里 UI 性能慢的原因.</strong></p><p>* WebView 单线程模型；<br>* DOM/CSS 排版复杂，渲染上需要大量计算；<br>* 动画是也很重要的考量因素。</p><p>多说两句动画。</p><p>最早做动画都是用 setTimeout/setInterval。<br>而 setTimeout/setInterval 的处理回调的时间 tick time 精度都在 16ms 左右。</p><p>所以，可以想象正常用这两个函数就已经 16 ms了，再加 reflow/repaint/compositing 卡顿或跳帧就是家常便饭了。</p><p>还好的是 w3c 标准和各浏览器厂商较早就支持了动画接口 RAF（RequestAnimationFrame 函数）来处理动画帧回调。解决了上述 setTimeout/setInterval Animation 不足的问题。</p><p><strong>DOM 性能低下的原因.</strong></p><p>浏览器执行的几个步骤：<br><img data-tag="bdshare" id="c1424010191587" class="content_image aligncenter" src="http://mmbiz.qpic.cn/mmbiz/fVKPLN9XPQKF0S04Z1CBTke2yq8FDytQ6ic6p5yFUlqTjVNSotefnPfKgaAEeeWVzNds8iakSHxRfcSogoA8ibS6w/0?tp=webp&amp;wxfrom=5" alt="" data-src="http://mmbiz.qpic.cn/mmbiz/fVKPLN9XPQKF0S04Z1CBTke2yq8FDytQ6ic6p5yFUlqTjVNSotefnPfKgaAEeeWVzNds8iakSHxRfcSogoA8ibS6w/0" data-rawwidth="466" data-rawheight="92" data-type="png" data-ratio="0.19742489270386265" data-w="466"><br>restyle/reflow/repaint 触发条件：</p><p><img data-tag="bdshare" id="c1424010191588" class="content_image aligncenter" src="http://mmbiz.qpic.cn/mmbiz/fVKPLN9XPQKF0S04Z1CBTke2yq8FDytQzb3MjvzOo5ewbmGe6ogMib6rSQTg7YRc6da7O4ZDHQRaIlLE04CB7Bg/0?tp=webp&amp;wxfrom=5" alt="" data-src="http://mmbiz.qpic.cn/mmbiz/fVKPLN9XPQKF0S04Z1CBTke2yq8FDytQzb3MjvzOo5ewbmGe6ogMib6rSQTg7YRc6da7O4ZDHQRaIlLE04CB7Bg/0" data-rawwidth="609" data-rawheight="300" data-type="png" data-ratio="0.4921259842519685" data-w="508"></p><p>了解完以上信息，考虑以下条件：</p><p>* 把 JavaScript 逻辑、复杂的 DOM 与样式合成，并完成渲染；<br>* HTTP 请求下载多媒体；<br>* 在一个线程里；<br>* 移动上的 ARM 架构；</p><p>以上操作能在每帧 16ms 里完成，想想都觉得是一件 TMD「不可思议」的事情。<br>于是各种各样的奇葩优化出现了。</p><p><strong>WebView 里高性能组件分类.</strong></p><p>已知的高性能组件的几类方法：</p><p><strong>1）常规方法</strong></p><p>这类的原理主要是利用人为或规范的方式，减少 restyle/reflow/repaint 触发次数：</p><p>* 通用组件优化 DOM 结构，甚至用 Virtual DOM（虚拟 DOM）减少 reflow 和 DOM 的复杂度；<br>* 优化 CSS，少用或跳过 repaint 阶段。用编译的手段识别部分 CSS，将 left/top 变换变成 transform；</p><p>跳过 layout 与 paint 阶段，就是多使用 Layer composite 技术，即 css 的「opacity」和「transform」属性作动画。</p><p>只能在 css 和 DOM 结构上去抠出些性能优化的空间，缺陷优化空间有限；这种优化技巧<strong>通常是放在最后调优时冲剌使用，不能做为常规手段。</strong></p><p><strong>2）进阶方法</strong></p><p>原理是尽可能利用 native 能力，甚至将 JavaScript 转换成 native App 代码。</p><p>* 用 JavaScript 调起 native 组件，将增强与高性能组件交给 native 来处理，以前在 FEX 提的「轻组件」就是这么做的。这个原理类似 PC 时代的 ActiveX；<br>* 将 WebView 里无法实现的功能用 native 实现。<br>* 利用 native Activity 的渲染线程，分担浏览器渲染压力（WebViewCoreThread 是 WebView 线程）。<br>* 最 dirty 的事在于处理 native 上 UI 的层次管理。需要后台有线程一直在检测 scroll/resize/ui change 时 UI 边界是否有相互覆盖与叠加的问题。</p><p>* JavaScript 翻译成 Java/OC 代码。类似 React Native/Titanium，将 JavaScript 翻译成 native 代码，特别是 UI 组件上。（有兴趣的同学可以反编译 React Native 写的 Facebook Group）<br>* 例：用 React，通过虚拟 Web UI 映射至 Native View，并且将代码逻辑翻译成 native。</p><p><strong>3）新方法 — Canvas UI</strong></p><p>这也是要说的重点，用「开发游戏」的思路来做 UI 组件探索，我把它称为 Canvas UI framework。</p><p><strong>Canvas UI framework</strong></p><p>用游戏的思路做 UI，最早我有这个想法是 2014 年。</p><p><strong>为什么要用 Canvas?</strong></p><p>Canvas 是 H5 的画布元素，即一个 DOM 元素。通过脚本控制逻辑给画布上增加文字与图像，而浏览器只需要绘制一次形成一幅图。</p><p>* 只用一个 Canvas DOM 元素，降低 DOM 数量与渲染的复杂度，可以将原来 CPU 密集型变成 GPU 操作。绝大多数针对 Canvas 是用硬件 GPU 加速渲染。<br>* GPU 的 ALU（计算单元） 比 CPU 要多很多，而控制运算（逻辑）则可以用 JavaScript 在 CPU 里做，甚至还可以用 WebWorker 多线程处理 CPU 密集型的操作，从而达到充分利用硬件资源的能力。</p><p>* Canvas 画布无论是 JavaScript &amp; H5，还是 native 都有类似的 API。所以：<br>* 本地调试可在浏览器里完成。<br>* 最差方案可以用 Canvas UI 跑在浏览器里。<br>* 更进一步，可以把浏览器 Canvas 接口的反射到用 native 画布上，以此提高性能。</p><p>值得一提的是，腾迅的 X5 内核已经将 egret（白鹭游戏引擎与cocos2dx）内置，所以时间线拉长来看，WebView 的画布功能将会更加强大。</p><p>在 2014 年中时，很多人见识过默认置入 cocos2dx 引擎的浏览器，用 WebView 玩「捕鱼达人」很流畅。</p><p>由此说明 Canvas 做 UI 组件可行性还是蛮高的。</p><p><strong>解决方案.</strong></p><p>用游戏的思路来解决 DOM paint 的问题，业界早就有实验。<br>最早实验的是 zynga 做 angry birds 游戏的厂家，2010 年写的 demo scroller：</p><p>* https://github.com/zynga/scroller</p><p>设计、开发一个基于 Canvas 的 UI 框架系统，由于系统相对比较复杂，需接管浏览器构建的整个过程：</p><p>验证在实践环境中的效果，要把原来页面的 DOM 写成 canvas，再加上一些调优与比较，工作量相对大，（包括 zynga 也只是实现了一个简单的 demo 而已）</p><p>就暂时搁置了。</p><p>最近这阵子在翻 github 与新闻时，我惊喜的发现也有人在做同样的事了，最后发现 Flipboard 同学们写的一个 demo：<br>https://flipboard.com/@flipboard/flipboard-picks-8a1uu7ngz</p><p>&nbsp;</p><p>这个 demo 足够复杂，动画也足够多、炫。是用 canvas 来构建整个 UI。</p><p>测试过后：</p><p>* 这么复杂的 demo 在 MI4 以及配置以上性能很好，流畅度无限接近于 native，比较理想。<br>* 对比过 G+ 的 Android 应用，G+ 的 App 从动画上比 Flipboard 提供的的 demo 还「卡」些。<br>* 在小米 Note 上的动画流畅度已秒掉 iPhone 6，非常赞。</p><p>按照摩尔定律，可以预计明年 Note 的标配的 CPU 和 GPU 配置会成为主流。</p><p>而现在用 canvas UI 框架用在 MI4 以下机器仍然比较慢。而 2015 年 H5 开发 App，对很多公司来说只是 plan B 计划，大公司甚至 plan B 都不是。所以，如果一定要在纯 H5 上搞牛逼动画，还是再等等吧。</p><p><strong>布局系统 css layout.</strong></p><p>说回到 Canvas Component framework，回到我上面画的这张图：</p><p>UI 组件基于「文本」与「图像」。但 framework，除了 UI 组件本身以外，还需要有 Layout，而 css 只适用于浏览器本身的 layout 而无法适用于 Canvas 画布。</p><p>要给开发者好且排版可控的方案，那就要开发一个用 JavaScript 实现类似 CSS 的布局子集的框架。</p><p>否则 UI 的组件在画布上没有 layout 就无意义。</p><p>这个布局框架实现成本（简单实现）理论上并不大，大的是在于未来增加新 Feature 并相互组合时与浏览器本身有差异，需要有完整的 unit test。<br>正好最近 facebook 也开源了一个用 JavaScript 写 css layout 子集的解决方案，实现了：</p><p>* padding<br>* width<br>* margin<br>* border<br>* flex<br>* position( relative/absolute )</p><p>等等 Feature。</p><p>github 地址：https://github.com/facebook/css-layout</p><p>这些 css 布局子集基本能满足我们前期开发预期。</p><p><strong>开发框架.</strong></p><p>用 css-layout 再加上 UI 管理层，就可以比较清晰的实现出 canvas 的 UI 组件框架了。<br>那么，剩下的事就是：</p><p>* 应用开发框架的选择，如：选择 React/MVC 框架。<br>* 模拟 DOM 层次，即图层管理。</p><p>并且，让我非常欣喜的是，Flipboard 在 2 月已经完成了构建，基于 React 框架。<br>https://github.com/Flipboard/react-canvas</p><p>基于 css-layout + React 基础上整合而成。</p><p><strong>## Canvas UI 框架不足与风险</strong></p><p>看上去 Canvas 框架这么牛逼，但有很多缺陷。</p><p>* 对开发人员的要求较高。需要用 JavaScript 实现一些浏览器基本的布局、图层管理。<br>* 第三方使用者学习成本高。不象是用传统「标签」就可以实现 UI 在浏览器的输出。<br>* 开发者是否买账，对于框架的开发易用性有「很大」的挑战。<br>* 对开发质量提出新要求。由于所有的 UI 组件与交互都在画布 Canvas 里，所以调试成本比较高，需要有较为完整的 Logging 与 Debugging 方案。</p><p>* 用户可用性会受影响。例如：* 语音无法识别 Canvas 里的文字。* 无法象 WebView 里一样将画布里的文字选中并复制出来。</p><p><strong>总结.</strong></p><p>Canvas UI 框架作为柳暗花明又一村的技术。https://github.com/Flipboard/react-canvas 短短一周多，已经近 4K 的 star。确实很赞。<br>与其看 FB 开源 react native，不如好好研究 react-canvas 吧。</p></div>	' 
    }    
]